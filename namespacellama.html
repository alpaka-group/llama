<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Low-Level Abstraction of Memory Access: llama Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Low-Level Abstraction of Memory Access
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacellama.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">llama Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellama_1_1accessor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama_1_1accessor.html">accessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellama_1_1bloballoc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama_1_1bloballoc.html">bloballoc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellama_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellama_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama_1_1literals.html">literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacellama_1_1mapping"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama_1_1mapping.html">mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Array.html">Array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Array_3_01T_00_010_01_4.html">Array&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ArrayExtents_3_01T_01_4.html">ArrayExtents&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ArrayIndexIterator.html">ArrayIndexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structllama_1_1Iterator.html">Iterator</a> supporting <a class="el" href="structllama_1_1ArrayIndexRange.html">ArrayIndexRange</a>.  <a href="structllama_1_1ArrayIndexIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ArrayIndexRange.html">ArrayIndexRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range allowing to iterate over all indices in an <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>.  <a href="structllama_1_1ArrayIndexRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy.html">Copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of <a class="el" href="namespacellama.html#ab67a5448cc031309dc1aa8580b7d4950">copy</a> defaulting to <a class="el" href="namespacellama.html#af977754d689a5f3cc10fd80d4b37ba1f">fieldWiseCopy</a>. LLAMA provides several specializations of this construct for specific mappings. Users are encouraged to also specialize this template with better copy algorithms for further combinations of mappings, if they can and want to provide a better implementation.  <a href="structllama_1_1Copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy_3_01Mapping_00_01Mapping_01_4.html">Copy&lt; Mapping, Mapping &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy_3_01mapping_1_1AoSoA_3_01ArrayExtents_00_01RecordDim_00_01LanesSrc_00_01Linecca40af6cbfeabebd92c0340cc1055ba.html">Copy&lt; mapping::AoSoA&lt; ArrayExtents, RecordDim, LanesSrc, LinearizeArrayIndex, PermuteFields &gt;, mapping::AoSoA&lt; ArrayExtents, RecordDim, LanesDst, LinearizeArrayIndex, PermuteFields &gt;, std::enable_if_t&lt; LanesSrc !=LanesDst &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy_3_01mapping_1_1AoSoA_3_01ArrayExtents_00_01RecordDim_00_01LanesSrc_00_01Line859743977e4e49efc57e47040098b4b8.html">Copy&lt; mapping::AoSoA&lt; ArrayExtents, RecordDim, LanesSrc, LinearizeArrayIndex, PermuteFields &gt;, mapping::SoA&lt; ArrayExtents, RecordDim, DstBlobs, DstSubArrayAlignment, LinearizeArrayIndex, PermuteFields &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy_3_01mapping_1_1SoA_3_01ArrayExtents_00_01RecordDim_00_01SrcBlobs_00_01SrcSub712ac8967d7b9cd8f921b93e85e89274.html">Copy&lt; mapping::SoA&lt; ArrayExtents, RecordDim, SrcBlobs, SrcSubArrayAlignment, LinearizeArrayIndex, PermuteFields &gt;, mapping::AoSoA&lt; ArrayExtents, RecordDim, LanesDst, LinearizeArrayIndex, PermuteFields &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Copy_3_01mapping_1_1SoA_3_01ArrayExtents_00_01RecordDim_00_01SrcBlobs_00_01SrcSubb9263f80fc3284e42fedd51b14aadf82.html">Copy&lt; mapping::SoA&lt; ArrayExtents, RecordDim, SrcBlobs, SrcSubArrayAlignment, LinearizeArrayIndex, PermuteFields &gt;, mapping::SoA&lt; ArrayExtents, RecordDim, DstBlobs, DstSubArrayAlignment, LinearizeArrayIndex, PermuteFields &gt;, std::enable_if_t&lt; SrcBlobs !=DstBlobs||SrcSubArrayAlignment !=DstSubArrayAlignment &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1NoName.html">NoName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anonymous naming for a <a class="el" href="structllama_1_1Field.html">Field</a>.  <a href="structllama_1_1NoName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Field.html">Field</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Record.html">Record</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type list of <a class="el" href="structllama_1_1Field.html">Field</a>s which may be used to define a record dimension.  <a href="structllama_1_1Record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1PrettySize.html">PrettySize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ProxyRefOpMixin.html">ProxyRefOpMixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP mixin for proxy reference types to support all compound assignment and increment/decrement operators.  <a href="structllama_1_1ProxyRefOpMixin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1RecordCoord_3_4.html">RecordCoord&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1RecordRef.html">RecordRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ScopedUpdate.html">ScopedUpdate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1ScopedUpdate_3_01Reference_00_01std_1_1enable__if__t_3_01std_1_1is__fundamental__e14f71eb64730a69a1b74dea5c5f8b59.html">ScopedUpdate&lt; Reference, std::enable_if_t&lt; std::is_fundamental_v&lt; typename internal::ValueOf&lt; Reference &gt;::type &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1SimdTraits.html">SimdTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1SimdTraits_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__arithmetic__v_3_01T_01_4_01_4_01_4.html">SimdTraits&lt; T, std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Tuple_3_01TFirstElement_00_01RestElements_8_8_8_01_4.html">Tuple&lt; TFirstElement, RestElements... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structllama_1_1Tuple.html">Tuple</a> class like <code>std::tuple</code> but suitable for use with offloading devices like GPUs.  <a href="structllama_1_1Tuple_3_01TFirstElement_00_01RestElements_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1View.html">View</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1Iterator.html">Iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllama_1_1SubView.html">SubView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4611a0c2dd8c34c55b8a72da6da7ace2"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , std::size_t N, SizeType Extent&gt; </td></tr>
<tr class="memitem:a4611a0c2dd8c34c55b8a72da6da7ace2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4611a0c2dd8c34c55b8a72da6da7ace2">ArrayExtentsNCube</a> = decltype(<a class="el" href="namespacellama_1_1internal.html#aa53f8a0b5fadc80cbc91b1b8a1d7633c">internal::makeArrayExtents</a>&lt; SizeType, Extent &gt;(std::make_index_sequence&lt; N &gt;{}))</td></tr>
<tr class="memdesc:a4611a0c2dd8c34c55b8a72da6da7ace2"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> where all N extents are Extent.  <a href="namespacellama.html#a4611a0c2dd8c34c55b8a72da6da7ace2">More...</a><br /></td></tr>
<tr class="separator:a4611a0c2dd8c34c55b8a72da6da7ace2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224063aae62355b61616e5d59c8e8517"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , std::size_t N&gt; </td></tr>
<tr class="memitem:a224063aae62355b61616e5d59c8e8517"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a224063aae62355b61616e5d59c8e8517">ArrayExtentsDynamic</a> = <a class="el" href="namespacellama.html#a4611a0c2dd8c34c55b8a72da6da7ace2">ArrayExtentsNCube</a>&lt; SizeType, N, <a class="el" href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">dyn</a> &gt;</td></tr>
<tr class="memdesc:a224063aae62355b61616e5d59c8e8517"><td class="mdescLeft">&#160;</td><td class="mdescRight">N-dimensional <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> where all values are dynamic.  <a href="namespacellama.html#a224063aae62355b61616e5d59c8e8517">More...</a><br /></td></tr>
<tr class="separator:a224063aae62355b61616e5d59c8e8517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca81dc9a7fe8571b47958428e8bfe231"><td class="memTemplParams" colspan="2">template&lt;typename Field &gt; </td></tr>
<tr class="memitem:aca81dc9a7fe8571b47958428e8bfe231"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aca81dc9a7fe8571b47958428e8bfe231">GetFieldTag</a> = mp_first&lt; <a class="el" href="structllama_1_1Field.html">Field</a> &gt;</td></tr>
<tr class="memdesc:aca81dc9a7fe8571b47958428e8bfe231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tag from a <a class="el" href="structllama_1_1Field.html">Field</a>.  <a href="namespacellama.html#aca81dc9a7fe8571b47958428e8bfe231">More...</a><br /></td></tr>
<tr class="separator:aca81dc9a7fe8571b47958428e8bfe231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dfd56127d13358c2991a57340657dc"><td class="memTemplParams" colspan="2">template&lt;typename Field &gt; </td></tr>
<tr class="memitem:a75dfd56127d13358c2991a57340657dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">GetFieldType</a> = mp_second&lt; <a class="el" href="structllama_1_1Field.html">Field</a> &gt;</td></tr>
<tr class="memdesc:a75dfd56127d13358c2991a57340657dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type from a <a class="el" href="structllama_1_1Field.html">Field</a>.  <a href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">More...</a><br /></td></tr>
<tr class="separator:a75dfd56127d13358c2991a57340657dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4fd33218cce7b2e592486d80f2ae90"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename RecordCoord &gt; </td></tr>
<tr class="memitem:a4a4fd33218cce7b2e592486d80f2ae90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4a4fd33218cce7b2e592486d80f2ae90">GetTags</a> = typename <a class="el" href="structllama_1_1internal_1_1GetTagsImpl.html">internal::GetTagsImpl</a>&lt; RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> &gt;::type</td></tr>
<tr class="separator:a4a4fd33218cce7b2e592486d80f2ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9a9464eb5c520170ea7911bac60863"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename RecordCoord &gt; </td></tr>
<tr class="memitem:a5c9a9464eb5c520170ea7911bac60863"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a5c9a9464eb5c520170ea7911bac60863">GetTag</a> = typename <a class="el" href="structllama_1_1internal_1_1GetTagImpl.html">internal::GetTagImpl</a>&lt; RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> &gt;::type</td></tr>
<tr class="memdesc:a5c9a9464eb5c520170ea7911bac60863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tag of the <a class="el" href="structllama_1_1Field.html">Field</a> at a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> inside the record dimension tree.  <a href="namespacellama.html#a5c9a9464eb5c520170ea7911bac60863">More...</a><br /></td></tr>
<tr class="separator:a5c9a9464eb5c520170ea7911bac60863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1474c16fc91cddf593cb83ac1234619"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename... TagsOrTagList&gt; </td></tr>
<tr class="memitem:ac1474c16fc91cddf593cb83ac1234619"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ac1474c16fc91cddf593cb83ac1234619">GetCoordFromTags</a> = typename <a class="el" href="structllama_1_1internal_1_1GetCoordFromTagsImpl.html">internal::GetCoordFromTagsImpl</a>&lt; RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, TagsOrTagList... &gt;::type</td></tr>
<tr class="separator:ac1474c16fc91cddf593cb83ac1234619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfb627d325de5ab6c18cdc842cd7350"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename... RecordCoordOrTags&gt; </td></tr>
<tr class="memitem:acdfb627d325de5ab6c18cdc842cd7350"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#acdfb627d325de5ab6c18cdc842cd7350">GetType</a> = typename <a class="el" href="structllama_1_1internal_1_1GetTypeImpl.html">internal::GetTypeImpl</a>&lt; RecordDim, RecordCoordOrTags... &gt;::type</td></tr>
<tr class="separator:acdfb627d325de5ab6c18cdc842cd7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c1ac83b09aa8a960eca20d2aea3a98"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim &gt; </td></tr>
<tr class="memitem:ab0c1ac83b09aa8a960eca20d2aea3a98"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab0c1ac83b09aa8a960eca20d2aea3a98">LeafRecordCoords</a> = typename <a class="el" href="structllama_1_1internal_1_1LeafRecordCoordsImpl.html">internal::LeafRecordCoordsImpl</a>&lt; RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt; &gt;::type</td></tr>
<tr class="memdesc:ab0c1ac83b09aa8a960eca20d2aea3a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a flat type list containing all record coordinates to all leaves of the given record dimension.  <a href="namespacellama.html#ab0c1ac83b09aa8a960eca20d2aea3a98">More...</a><br /></td></tr>
<tr class="separator:ab0c1ac83b09aa8a960eca20d2aea3a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fddf1f638927edfb8da8e3c78da4e1c"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim &gt; </td></tr>
<tr class="memitem:a1fddf1f638927edfb8da8e3c78da4e1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a> = typename <a class="el" href="structllama_1_1internal_1_1FlattenRecordDimImpl.html">internal::FlattenRecordDimImpl</a>&lt; RecordDim &gt;::type</td></tr>
<tr class="memdesc:a1fddf1f638927edfb8da8e3c78da4e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a flat type list containing all leaf field types of the given record dimension.  <a href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">More...</a><br /></td></tr>
<tr class="separator:a1fddf1f638927edfb8da8e3c78da4e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee3ebd8a4ac86fffc2c6e5cc1a3ac71"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename, typename &gt; typename FieldTypeFunctor&gt; </td></tr>
<tr class="memitem:aaee3ebd8a4ac86fffc2c6e5cc1a3ac71"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aaee3ebd8a4ac86fffc2c6e5cc1a3ac71">TransformLeavesWithCoord</a> = typename <a class="el" href="structllama_1_1internal_1_1TransformLeavesWithCoordImpl.html">internal::TransformLeavesWithCoordImpl</a>&lt; <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, RecordDim, FieldTypeFunctor &gt;::type</td></tr>
<tr class="separator:aaee3ebd8a4ac86fffc2c6e5cc1a3ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825425dc4761ab3b27c3ec6d42876f32"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename &gt; typename FieldTypeFunctor&gt; </td></tr>
<tr class="memitem:a825425dc4761ab3b27c3ec6d42876f32"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a825425dc4761ab3b27c3ec6d42876f32">TransformLeaves</a> = <a class="el" href="namespacellama.html#aaee3ebd8a4ac86fffc2c6e5cc1a3ac71">TransformLeavesWithCoord</a>&lt; RecordDim, <a class="el" href="structllama_1_1internal_1_1MakePassSecond.html">internal::MakePassSecond</a>&lt; FieldTypeFunctor &gt;::template fn &gt;</td></tr>
<tr class="separator:a825425dc4761ab3b27c3ec6d42876f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77dc388b0806851df1b1834ad4a31e0"><td class="memTemplParams" colspan="2">template&lt;typename RecordDimA , typename RecordDimB &gt; </td></tr>
<tr class="memitem:ab77dc388b0806851df1b1834ad4a31e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab77dc388b0806851df1b1834ad4a31e0">MergedRecordDims</a> = typename decltype(<a class="el" href="namespacellama_1_1internal.html#ab4ccd5eb73c48197b867b5fe4c98c55f">internal::mergeRecordDimsImpl</a>(mp_identity&lt; RecordDimA &gt;{}, mp_identity&lt; RecordDimB &gt;{}))::type</td></tr>
<tr class="memdesc:ab77dc388b0806851df1b1834ad4a31e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a merged record dimension, where duplicated, nested fields are unified.  <a href="namespacellama.html#ab77dc388b0806851df1b1834ad4a31e0">More...</a><br /></td></tr>
<tr class="separator:ab77dc388b0806851df1b1834ad4a31e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d11eb31b39aeb9471429ced9d7a484"><td class="memTemplParams" colspan="2">template&lt;typename FromT , typename ToT &gt; </td></tr>
<tr class="memitem:aa7d11eb31b39aeb9471429ced9d7a484"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aa7d11eb31b39aeb9471429ced9d7a484">CopyConst</a> = std::conditional_t&lt; std::is_const_v&lt; FromT &gt;, const ToT, ToT &gt;</td></tr>
<tr class="memdesc:aa7d11eb31b39aeb9471429ced9d7a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for ToT, adding <code>const</code> if FromT is const qualified.  <a href="namespacellama.html#aa7d11eb31b39aeb9471429ced9d7a484">More...</a><br /></td></tr>
<tr class="separator:aa7d11eb31b39aeb9471429ced9d7a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af0304a902bcb5c5c90377ad751033a"><td class="memTemplParams" colspan="2">template&lt;auto V&gt; </td></tr>
<tr class="memitem:a0af0304a902bcb5c5c90377ad751033a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0af0304a902bcb5c5c90377ad751033a">Constant</a> = std::integral_constant&lt; decltype(V), V &gt;</td></tr>
<tr class="memdesc:a0af0304a902bcb5c5c90377ad751033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as template argument to specify a constant/compile-time value.  <a href="namespacellama.html#a0af0304a902bcb5c5c90377ad751033a">More...</a><br /></td></tr>
<tr class="separator:a0af0304a902bcb5c5c90377ad751033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533ad08f0a1fa09005088a13a6b59040"><td class="memTemplParams" colspan="2">template&lt;typename Expression , typename... Args&gt; </td></tr>
<tr class="memitem:a533ad08f0a1fa09005088a13a6b59040"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a533ad08f0a1fa09005088a13a6b59040">ReplacePlaceholders</a> = typename <a class="el" href="structllama_1_1internal_1_1ReplacePlaceholdersImpl.html">internal::ReplacePlaceholdersImpl</a>&lt; Expression, Args... &gt;::type</td></tr>
<tr class="separator:a533ad08f0a1fa09005088a13a6b59040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95912a49a83091fde091a4e2d9a4118"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:ad95912a49a83091fde091a4e2d9a4118"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">RecordCoordFromList</a> = <a class="el" href="namespacellama_1_1internal.html#a81e3783dd94e3a1b003f955aaacf49d6">internal::mp_unwrap_values_into</a>&lt; L, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> &gt;</td></tr>
<tr class="memdesc:ad95912a49a83091fde091a4e2d9a4118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a type list of integral constants into a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>.  <a href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">More...</a><br /></td></tr>
<tr class="separator:ad95912a49a83091fde091a4e2d9a4118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92a835e40a98002ba3b05c050d00cf"><td class="memTemplParams" colspan="2">template&lt;typename... RecordCoords&gt; </td></tr>
<tr class="memitem:aca92a835e40a98002ba3b05c050d00cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aca92a835e40a98002ba3b05c050d00cf">Cat</a> = <a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">RecordCoordFromList</a>&lt; mp_append&lt; typename RecordCoords::List... &gt; &gt;</td></tr>
<tr class="memdesc:aca92a835e40a98002ba3b05c050d00cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a set of <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s.  <a href="namespacellama.html#aca92a835e40a98002ba3b05c050d00cf">More...</a><br /></td></tr>
<tr class="separator:aca92a835e40a98002ba3b05c050d00cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dcbb30751c7c23e97d434736a0acc4"><td class="memTemplParams" colspan="2">template&lt;typename RecordCoord &gt; </td></tr>
<tr class="memitem:a51dcbb30751c7c23e97d434736a0acc4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a51dcbb30751c7c23e97d434736a0acc4">PopFront</a> = <a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">RecordCoordFromList</a>&lt; mp_pop_front&lt; typename <a class="el" href="structllama_1_1RecordCoord.html#a685a368d5b00931fb77af19012b10b4b">RecordCoord::List</a> &gt; &gt;</td></tr>
<tr class="memdesc:a51dcbb30751c7c23e97d434736a0acc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> without first coordinate component.  <a href="namespacellama.html#a51dcbb30751c7c23e97d434736a0acc4">More...</a><br /></td></tr>
<tr class="separator:a51dcbb30751c7c23e97d434736a0acc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5050ae091b407bcd3adabb734f2aba0"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd&gt; </td></tr>
<tr class="memitem:ab5050ae091b407bcd3adabb734f2aba0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">SimdizeN</a> = typename <a class="el" href="structllama_1_1internal_1_1SimdizeNImpl.html">internal::SimdizeNImpl</a>&lt; RecordDim, N, MakeSizedSimd &gt;::type</td></tr>
<tr class="separator:ab5050ae091b407bcd3adabb734f2aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf54146d2fef06baf9d512e22793f41a"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </td></tr>
<tr class="memitem:adf54146d2fef06baf9d512e22793f41a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">Simdize</a> = <a class="el" href="namespacellama.html#a825425dc4761ab3b27c3ec6d42876f32">TransformLeaves</a>&lt; RecordDim, MakeSimd &gt;</td></tr>
<tr class="separator:adf54146d2fef06baf9d512e22793f41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1e01829ca6b6d3a50720fdbcc99adf"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd&gt; </td></tr>
<tr class="memitem:a2f1e01829ca6b6d3a50720fdbcc99adf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a2f1e01829ca6b6d3a50720fdbcc99adf">SimdN</a> = typename std::conditional_t&lt; <a class="el" href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">isRecordDim</a>&lt; T &gt;, std::conditional_t&lt; N==1, mp_identity&lt; <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt; T &gt; &gt;, mp_identity&lt; <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt; <a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">SimdizeN</a>&lt; T, N, MakeSizedSimd &gt; &gt;&gt; &gt;, std::conditional_t&lt; N==1, mp_identity&lt; T &gt;, mp_identity&lt; <a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">SimdizeN</a>&lt; T, N, MakeSizedSimd &gt; &gt;&gt; &gt;::type</td></tr>
<tr class="separator:a2f1e01829ca6b6d3a50720fdbcc99adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf42387a56b588d4a261b9ab869e33ee"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename &gt; typename MakeSimd&gt; </td></tr>
<tr class="memitem:adf42387a56b588d4a261b9ab869e33ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> = typename std::conditional_t&lt; <a class="el" href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">isRecordDim</a>&lt; T &gt;, mp_identity&lt; <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt; <a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">Simdize</a>&lt; T, MakeSimd &gt; &gt;&gt;, mp_identity&lt; <a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">Simdize</a>&lt; T, MakeSimd &gt; &gt;&gt;::type</td></tr>
<tr class="separator:adf42387a56b588d4a261b9ab869e33ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b33b2c30fa081e8352cf12c7b98b0eb"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim &gt; </td></tr>
<tr class="memitem:a7b33b2c30fa081e8352cf12c7b98b0eb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> = <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; decltype(<a class="el" href="namespacellama.html#a3e6032b02494ed6d889e8612fa5006dd">allocScalarView</a>&lt; 0, RecordDim &gt;()), <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, true &gt;</td></tr>
<tr class="memdesc:a7b33b2c30fa081e8352cf12c7b98b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a> that owns and holds a single value.  <a href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">More...</a><br /></td></tr>
<tr class="separator:a7b33b2c30fa081e8352cf12c7b98b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a690689d38b43930430e58bb7fe17aca7"><td class="memTemplParams" colspan="2">template&lt;typename First , typename... Args&gt; </td></tr>
<tr class="memitem:a690689d38b43930430e58bb7fe17aca7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a690689d38b43930430e58bb7fe17aca7">Array</a> (First, Args... args) -&gt; <a class="el" href="structllama_1_1Array.html">Array</a>&lt; First, sizeof...(Args)+1 &gt;</td></tr>
<tr class="separator:a690689d38b43930430e58bb7fe17aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9492ccf576f0f3683d893e35882a54"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6b9492ccf576f0f3683d893e35882a54"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a6b9492ccf576f0f3683d893e35882a54">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; &amp;a) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:a6b9492ccf576f0f3683d893e35882a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bf42db36a3e21c7819a833ed76ed2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:afa7bf42db36a3e21c7819a833ed76ed2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#afa7bf42db36a3e21c7819a833ed76ed2">pushFront</a> ([[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a, T v) -&gt; <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N+1 &gt;</td></tr>
<tr class="separator:afa7bf42db36a3e21c7819a833ed76ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582387ea1287dbab16833fc8da254d58"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a582387ea1287dbab16833fc8da254d58"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a582387ea1287dbab16833fc8da254d58">pushBack</a> ([[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a, T v) -&gt; <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N+1 &gt;</td></tr>
<tr class="separator:a582387ea1287dbab16833fc8da254d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b682ef182dc8da7ec372afc84f1abc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a73b682ef182dc8da7ec372afc84f1abc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a73b682ef182dc8da7ec372afc84f1abc">popBack</a> ([[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:a73b682ef182dc8da7ec372afc84f1abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b41ee8951d9b20dfbdc8630ea6e92"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac72b41ee8951d9b20dfbdc8630ea6e92"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ac72b41ee8951d9b20dfbdc8630ea6e92">popFront</a> ([[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a)</td></tr>
<tr class="separator:ac72b41ee8951d9b20dfbdc8630ea6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab7973f7686f93f02ad33e4d0636a25"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abab7973f7686f93f02ad33e4d0636a25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#abab7973f7686f93f02ad33e4d0636a25">product</a> (<a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a) -&gt; T</td></tr>
<tr class="separator:abab7973f7686f93f02ad33e4d0636a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672915c49821a718f5dfa5d4540c4192"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a672915c49821a718f5dfa5d4540c4192"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a672915c49821a718f5dfa5d4540c4192">dot</a> ([[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; a, [[maybe_unused]] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; b) -&gt; T</td></tr>
<tr class="separator:a672915c49821a718f5dfa5d4540c4192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491b771e37f3d0b8668883df9d0c02d0"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a491b771e37f3d0b8668883df9d0c02d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a491b771e37f3d0b8668883df9d0c02d0">operator==</a> (<a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TA, Dim &gt; a, <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TB, Dim &gt; b) -&gt; bool</td></tr>
<tr class="separator:a491b771e37f3d0b8668883df9d0c02d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91513e7294d6476ee4c4362a4093997f"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a91513e7294d6476ee4c4362a4093997f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a91513e7294d6476ee4c4362a4093997f">operator!=</a> (<a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TA, Dim &gt; a, <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TB, Dim &gt; b) -&gt; bool</td></tr>
<tr class="separator:a91513e7294d6476ee4c4362a4093997f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0fda5486eb5976f940a638f0cdd9d4"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0d0fda5486eb5976f940a638f0cdd9d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0d0fda5486eb5976f940a638f0cdd9d4">ArrayIndex</a> (Args...) -&gt; <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1IndexTypeFromArgs.html">internal::IndexTypeFromArgs</a>&lt; std::size_t, Args... &gt;::type, sizeof...(Args)&gt;</td></tr>
<tr class="separator:a0d0fda5486eb5976f940a638f0cdd9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fccafcd85a44696a4d5e6659927b634"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3fccafcd85a44696a4d5e6659927b634"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a3fccafcd85a44696a4d5e6659927b634">ArrayExtents</a> (Args...) -&gt; <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1IndexTypeFromArgs.html">internal::IndexTypeFromArgs</a>&lt; std::size_t, Args... &gt;::type,(Args{}, <a class="el" href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">dyn</a>)... &gt;</td></tr>
<tr class="separator:a3fccafcd85a44696a4d5e6659927b634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8ee545443974c602115ab987f05e7"><td class="memTemplParams" colspan="2">template&lt;typename SizeTypeA , SizeTypeA... SizesA, typename SizeTypeB , SizeTypeB... SizesB&gt; </td></tr>
<tr class="memitem:a1cb8ee545443974c602115ab987f05e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1cb8ee545443974c602115ab987f05e7">operator==</a> (<a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeA, SizesA... &gt; a, <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeB, SizesB... &gt; b) -&gt; bool</td></tr>
<tr class="separator:a1cb8ee545443974c602115ab987f05e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa969f915a561005ba54a2c698a184965"><td class="memTemplParams" colspan="2">template&lt;typename SizeTypeA , SizeTypeA... SizesA, typename SizeTypeB , SizeTypeB... SizesB&gt; </td></tr>
<tr class="memitem:aa969f915a561005ba54a2c698a184965"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aa969f915a561005ba54a2c698a184965">operator!=</a> (<a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeA, SizesA... &gt; a, <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeB, SizesB... &gt; b) -&gt; bool</td></tr>
<tr class="separator:aa969f915a561005ba54a2c698a184965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f71db415ea884ba0c9d22a9bf5414"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , SizeType... Sizes&gt; </td></tr>
<tr class="memitem:acb7f71db415ea884ba0c9d22a9bf5414"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#acb7f71db415ea884ba0c9d22a9bf5414">product</a> (<a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeType, Sizes... &gt; e) -&gt; SizeType</td></tr>
<tr class="separator:acb7f71db415ea884ba0c9d22a9bf5414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf3984cdb9b597c147f06626114575"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , std::size_t Dim, typename Func , typename... OuterIndices&gt; </td></tr>
<tr class="memitem:a1abf3984cdb9b597c147f06626114575"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1abf3984cdb9b597c147f06626114575">forEachArrayIndex</a> ([[maybe_unused]] const <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; SizeType, Dim &gt; &amp;extents, Func &amp;&amp;func, OuterIndices... outerIndices)</td></tr>
<tr class="separator:a1abf3984cdb9b597c147f06626114575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372264ea5e1f1bbbd0d89ffd5a9a77a2"><td class="memTemplParams" colspan="2">template&lt;typename SizeType , SizeType... Sizes, typename Func &gt; </td></tr>
<tr class="memitem:a372264ea5e1f1bbbd0d89ffd5a9a77a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a372264ea5e1f1bbbd0d89ffd5a9a77a2">forEachArrayIndex</a> (<a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeType, Sizes... &gt; extents, Func &amp;&amp;func)</td></tr>
<tr class="separator:a372264ea5e1f1bbbd0d89ffd5a9a77a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4959ae52801ba64e6f6c3ba612de29b7"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename SrcBlob , typename DstBlob , typename MemcpyFunc  = decltype(internal::memcpy)&gt; </td></tr>
<tr class="memitem:a4959ae52801ba64e6f6c3ba612de29b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4959ae52801ba64e6f6c3ba612de29b7">memcpyBlobs</a> (const <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, SrcBlob &gt; &amp;srcView, <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, DstBlob &gt; &amp;dstView, std::size_t threadId=0, std::size_t threadCount=1, MemcpyFunc singleThreadMemcpy=<a class="el" href="namespacellama_1_1internal.html#ae7d043343c1a60a7ceb75ba7c06e4c18">internal::memcpy</a>)</td></tr>
<tr class="separator:a4959ae52801ba64e6f6c3ba612de29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f41c329ce5acee2de376b6640afcbe8"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename SrcBlob , typename DstBlob , typename BlobCopyFunc  = decltype(internal::copyBlobWithMemcpy)&gt; </td></tr>
<tr class="memitem:a2f41c329ce5acee2de376b6640afcbe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a2f41c329ce5acee2de376b6640afcbe8">copyBlobs</a> (const <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, SrcBlob &gt; &amp;srcView, <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, DstBlob &gt; &amp;dstView, BlobCopyFunc copyBlob=<a class="el" href="namespacellama_1_1internal.html#a1c6df394c66fe2b06db0c0ad6a5e7b12">internal::copyBlobWithMemcpy</a>)</td></tr>
<tr class="separator:a2f41c329ce5acee2de376b6640afcbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af977754d689a5f3cc10fd80d4b37ba1f"><td class="memTemplParams" colspan="2">template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </td></tr>
<tr class="memitem:af977754d689a5f3cc10fd80d4b37ba1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af977754d689a5f3cc10fd80d4b37ba1f">fieldWiseCopy</a> (const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;srcView, <a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;dstView, std::size_t threadId=0, std::size_t threadCount=1)</td></tr>
<tr class="separator:af977754d689a5f3cc10fd80d4b37ba1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaefce711ff5d4566ea761ef08fab469"><td class="memTemplParams" colspan="2">template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </td></tr>
<tr class="memitem:abaefce711ff5d4566ea761ef08fab469"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#abaefce711ff5d4566ea761ef08fab469">aosoaCommonBlockCopy</a> (const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;srcView, <a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;dstView, bool readOpt, std::size_t threadId=0, std::size_t threadCount=1)</td></tr>
<tr class="separator:abaefce711ff5d4566ea761ef08fab469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67a5448cc031309dc1aa8580b7d4950"><td class="memTemplParams" colspan="2">template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </td></tr>
<tr class="memitem:ab67a5448cc031309dc1aa8580b7d4950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab67a5448cc031309dc1aa8580b7d4950">copy</a> (const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;srcView, <a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;dstView, std::size_t threadId=0, std::size_t threadCount=1)</td></tr>
<tr class="separator:ab67a5448cc031309dc1aa8580b7d4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2a1438ebfa33ecdae893ab0b93e37"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a33a2a1438ebfa33ecdae893ab0b93e37"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a33a2a1438ebfa33ecdae893ab0b93e37">NrAndOffset</a> (Int, Int) -&gt; <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; Int &gt;</td></tr>
<tr class="separator:a33a2a1438ebfa33ecdae893ab0b93e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7f2c72590f73698ff6f31ba44ec0a3"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a5c7f2c72590f73698ff6f31ba44ec0a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a5c7f2c72590f73698ff6f31ba44ec0a3">operator==</a> (const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TA &gt; &amp;a, const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TB &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a5c7f2c72590f73698ff6f31ba44ec0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8faed7400b66b8a3d13185ea2a26e4"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a4a8faed7400b66b8a3d13185ea2a26e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4a8faed7400b66b8a3d13185ea2a26e4">operator!=</a> (const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TA &gt; &amp;a, const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TB &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a4a8faed7400b66b8a3d13185ea2a26e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5d2462d07fc7d5cfa0dac05946c63"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename Functor , std::size_t... Coords&gt; </td></tr>
<tr class="memitem:a91f5d2462d07fc7d5cfa0dac05946c63"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a91f5d2462d07fc7d5cfa0dac05946c63">forEachLeafCoord</a> (Functor &amp;&amp;functor, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt; baseCoord)</td></tr>
<tr class="separator:a91f5d2462d07fc7d5cfa0dac05946c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ad5ce29085756570effc3b27378a5c"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename Functor , typename... Tags&gt; </td></tr>
<tr class="memitem:a28ad5ce29085756570effc3b27378a5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a28ad5ce29085756570effc3b27378a5c">forEachLeafCoord</a> (Functor &amp;&amp;functor, Tags...)</td></tr>
<tr class="separator:a28ad5ce29085756570effc3b27378a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516c8260631ec1b61a52f0e56dc58ac7"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a516c8260631ec1b61a52f0e56dc58ac7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a516c8260631ec1b61a52f0e56dc58ac7">divCeil</a> (Integral a, Integral b) -&gt; Integral</td></tr>
<tr class="memdesc:a516c8260631ec1b61a52f0e56dc58ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ceiling of a / b.  <a href="namespacellama.html#a516c8260631ec1b61a52f0e56dc58ac7">More...</a><br /></td></tr>
<tr class="separator:a516c8260631ec1b61a52f0e56dc58ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c5c0a1ca0698a8871689b9924736ac"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ab9c5c0a1ca0698a8871689b9924736ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab9c5c0a1ca0698a8871689b9924736ac">roundUpToMultiple</a> (Integral n, Integral mult) -&gt; Integral</td></tr>
<tr class="memdesc:ab9c5c0a1ca0698a8871689b9924736ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integral n rounded up to be a multiple of mult.  <a href="namespacellama.html#ab9c5c0a1ca0698a8871689b9924736ac">More...</a><br /></td></tr>
<tr class="separator:ab9c5c0a1ca0698a8871689b9924736ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6efa2eebd35614750c0404652a0f7d2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama.html#af6efa2eebd35614750c0404652a0f7d2">prettySize</a> (double size) -&gt; <a class="el" href="structllama_1_1PrettySize.html">PrettySize</a></td></tr>
<tr class="separator:af6efa2eebd35614750c0404652a0f7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bf07b53ebc403eee401038fc95b591"><td class="memTemplParams" colspan="2">template&lt;std::size_t PieceLength, typename Mapping &gt; </td></tr>
<tr class="memitem:a32bf07b53ebc403eee401038fc95b591"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a32bf07b53ebc403eee401038fc95b591">mapsPiecewiseContiguous</a> (const Mapping &amp;m) -&gt; bool</td></tr>
<tr class="separator:a32bf07b53ebc403eee401038fc95b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf2ad9d154fb837e684d57779272efb"><td class="memTemplParams" colspan="2">template&lt;std::size_t... CoordsA, std::size_t... CoordsB&gt; </td></tr>
<tr class="memitem:abdf2ad9d154fb837e684d57779272efb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#abdf2ad9d154fb837e684d57779272efb">operator==</a> (<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsA... &gt;, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsB... &gt;)</td></tr>
<tr class="separator:abdf2ad9d154fb837e684d57779272efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa8382ac8cefc8c2efceb8e4dab263a"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Coords&gt; </td></tr>
<tr class="memitem:a8aa8382ac8cefc8c2efceb8e4dab263a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a8aa8382ac8cefc8c2efceb8e4dab263a">operator==</a> (<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;)</td></tr>
<tr class="separator:a8aa8382ac8cefc8c2efceb8e4dab263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20099242b7f987d98d361a5f46ab90ae"><td class="memTemplParams" colspan="2">template&lt;std::size_t... CoordsA, std::size_t... CoordsB&gt; </td></tr>
<tr class="memitem:a20099242b7f987d98d361a5f46ab90ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a20099242b7f987d98d361a5f46ab90ae">operator!=</a> (<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsA... &gt; a, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsB... &gt; b)</td></tr>
<tr class="separator:a20099242b7f987d98d361a5f46ab90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056e745a18ef7e0342d719e1ce678b17"><td class="memTemplParams" colspan="2">template&lt;std::size_t... RCs&gt; </td></tr>
<tr class="memitem:a056e745a18ef7e0342d719e1ce678b17"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a056e745a18ef7e0342d719e1ce678b17">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; RCs... &gt;) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:a056e745a18ef7e0342d719e1ce678b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe5ae24f96109b3ca3d05eaf550e880"><td class="memTemplParams" colspan="2">template&lt;char... Digits&gt; </td></tr>
<tr class="memitem:aafe5ae24f96109b3ca3d05eaf550e880"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama_1_1literals.html#aafe5ae24f96109b3ca3d05eaf550e880">operator&quot;&quot;_RC</a> ()</td></tr>
<tr class="memdesc:aafe5ae24f96109b3ca3d05eaf550e880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literal operator for converting a numeric literal into a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>.  <a href="namespacellama_1_1literals.html#aafe5ae24f96109b3ca3d05eaf550e880">More...</a><br /></td></tr>
<tr class="separator:aafe5ae24f96109b3ca3d05eaf550e880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cdd926d98388052f028ab19c94b649"><td class="memTemplParams" colspan="2">template&lt;typename... RecordCoords&gt; </td></tr>
<tr class="memitem:a42cdd926d98388052f028ab19c94b649"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a42cdd926d98388052f028ab19c94b649">cat</a> (RecordCoords...)</td></tr>
<tr class="memdesc:a42cdd926d98388052f028ab19c94b649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a set of <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s instances.  <a href="namespacellama.html#a42cdd926d98388052f028ab19c94b649">More...</a><br /></td></tr>
<tr class="separator:a42cdd926d98388052f028ab19c94b649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca680f97ca52a42cd74519e6347395"><td class="memTemplParams" colspan="2">template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </td></tr>
<tr class="memitem:a4fca680f97ca52a42cd74519e6347395"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4fca680f97ca52a42cd74519e6347395">copyRecord</a> (const <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, OwnView &gt; &amp;rr)</td></tr>
<tr class="memdesc:a4fca680f97ca52a42cd74519e6347395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> with the same record dimension as the given record ref, with values copyied from rr.  <a href="namespacellama.html#a4fca680f97ca52a42cd74519e6347395">More...</a><br /></td></tr>
<tr class="separator:a4fca680f97ca52a42cd74519e6347395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf7c7c54c4190a57a2cc1ad5c280453"><td class="memTemplParams" colspan="2">template&lt;typename ViewA , typename BoundRecordDimA , bool OwnViewA, typename ViewB , typename BoundRecordDimB , bool OwnViewB&gt; </td></tr>
<tr class="memitem:aebf7c7c54c4190a57a2cc1ad5c280453"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aebf7c7c54c4190a57a2cc1ad5c280453">swap</a> (<a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewA, BoundRecordDimA, OwnViewA &gt; &amp;a, <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewB, BoundRecordDimB, OwnViewB &gt; &amp;b) noexcept -&gt; std::enable_if_t&lt; std::is_same_v&lt; typename <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewA, BoundRecordDimA, OwnViewA &gt;::AccessibleRecordDim, typename <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewB, BoundRecordDimB, OwnViewB &gt;::AccessibleRecordDim &gt;&gt;</td></tr>
<tr class="separator:aebf7c7c54c4190a57a2cc1ad5c280453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7c3018578c28fe8a22d817570dbfca"><td class="memTemplParams" colspan="2">template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </td></tr>
<tr class="memitem:a4d7c3018578c28fe8a22d817570dbfca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4d7c3018578c28fe8a22d817570dbfca">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, OwnView &gt; &amp;vr) -&gt; std::ostream &amp;</td></tr>
<tr class="separator:a4d7c3018578c28fe8a22d817570dbfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc8837b94b46c9989ce0e7fe8c172ac"><td class="memTemplParams" colspan="2">template&lt;typename RecordRefFwd , typename Functor &gt; </td></tr>
<tr class="memitem:aacc8837b94b46c9989ce0e7fe8c172ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aacc8837b94b46c9989ce0e7fe8c172ac">forEachLeaf</a> (RecordRefFwd &amp;&amp;vr, Functor &amp;&amp;functor)</td></tr>
<tr class="separator:aacc8837b94b46c9989ce0e7fe8c172ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8572ce32d64cda19cb705d78247bed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f8572ce32d64cda19cb705d78247bed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0f8572ce32d64cda19cb705d78247bed">decayCopy</a> (T &amp;&amp;valueOrRef) -&gt; typename <a class="el" href="structllama_1_1internal_1_1ValueOf.html">internal::ValueOf</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a0f8572ce32d64cda19cb705d78247bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls a copy of the given value or reference. Proxy references are resolved to their value types.  <a href="namespacellama.html#a0f8572ce32d64cda19cb705d78247bed">More...</a><br /></td></tr>
<tr class="separator:a0f8572ce32d64cda19cb705d78247bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dddd17106d2711c85b213e61fb9155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7dddd17106d2711c85b213e61fb9155"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ad7dddd17106d2711c85b213e61fb9155">ScopedUpdate</a> (T) -&gt; <a class="el" href="structllama_1_1ScopedUpdate.html">ScopedUpdate</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1ReferenceTo.html">internal::ReferenceTo</a>&lt; std::remove_reference_t&lt; T &gt;&gt;::type &gt;</td></tr>
<tr class="separator:ad7dddd17106d2711c85b213e61fb9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21e8bcb7c41613b7183a1beef1f600"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd, typename BinaryReductionFunction &gt; </td></tr>
<tr class="memitem:abb21e8bcb7c41613b7183a1beef1f600"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#abb21e8bcb7c41613b7183a1beef1f600">chooseSimdLanes</a> (BinaryReductionFunction reduce) -&gt; std::size_t</td></tr>
<tr class="separator:abb21e8bcb7c41613b7183a1beef1f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6060f4836e56bda4689232f0d22fecf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Simd &gt; </td></tr>
<tr class="memitem:a6060f4836e56bda4689232f0d22fecf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a6060f4836e56bda4689232f0d22fecf8">loadSimd</a> (const T &amp;srcRef, <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> &amp;dstSimd)</td></tr>
<tr class="separator:a6060f4836e56bda4689232f0d22fecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85a654e961eeb097cb3b557850e668b"><td class="memTemplParams" colspan="2">template&lt;typename Simd , typename TFwd &gt; </td></tr>
<tr class="memitem:ad85a654e961eeb097cb3b557850e668b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ad85a654e961eeb097cb3b557850e668b">storeSimd</a> (const <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> &amp;srcSimd, TFwd &amp;&amp;dstRef)</td></tr>
<tr class="separator:ad85a654e961eeb097cb3b557850e668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4451ec281eb037ebac7c08772ce0670f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd, typename View , typename UnarySimdFunction &gt; </td></tr>
<tr class="memitem:a4451ec281eb037ebac7c08772ce0670f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4451ec281eb037ebac7c08772ce0670f">simdForEachN</a> (<a class="el" href="structllama_1_1View.html">View</a> &amp;view, UnarySimdFunction f)</td></tr>
<tr class="separator:a4451ec281eb037ebac7c08772ce0670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebdbc18176bbf81e01c2b268665a94c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; typename MakeSimd, template&lt; typename, auto &gt; typename MakeSizedSimd, typename View , typename UnarySimdFunction &gt; </td></tr>
<tr class="memitem:acebdbc18176bbf81e01c2b268665a94c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#acebdbc18176bbf81e01c2b268665a94c">simdForEach</a> (<a class="el" href="structllama_1_1View.html">View</a> &amp;view, UnarySimdFunction f)</td></tr>
<tr class="separator:acebdbc18176bbf81e01c2b268665a94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8def4cdbf850f818833a38d67e6ebf34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8def4cdbf850f818833a38d67e6ebf34"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a8def4cdbf850f818833a38d67e6ebf34">structName</a> (T={}) -&gt; std::string_view</td></tr>
<tr class="separator:a8def4cdbf850f818833a38d67e6ebf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e34d4e183a7bcc5759082b3844c19ee"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , std::size_t... Coords&gt; </td></tr>
<tr class="memitem:a9e34d4e183a7bcc5759082b3844c19ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a9e34d4e183a7bcc5759082b3844c19ee">prettyRecordCoord</a> (<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;={}) -&gt; std::string_view</td></tr>
<tr class="separator:a9e34d4e183a7bcc5759082b3844c19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae605c0e18c4839602eb4e7f2d6696c22"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim &gt; </td></tr>
<tr class="memitem:ae605c0e18c4839602eb4e7f2d6696c22"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ae605c0e18c4839602eb4e7f2d6696c22">prettyRecordCoord</a> (<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;) -&gt; std::string_view</td></tr>
<tr class="separator:ae605c0e18c4839602eb4e7f2d6696c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1604e8162498ff814c1b1efacd212e95"><td class="memTemplParams" colspan="2">template&lt;typename... Elements&gt; </td></tr>
<tr class="memitem:a1604e8162498ff814c1b1efacd212e95"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1604e8162498ff814c1b1efacd212e95">Tuple</a> (Elements...) -&gt; <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; std::remove_cv_t&lt; std::remove_reference_t&lt; Elements &gt;&gt;... &gt;</td></tr>
<tr class="separator:a1604e8162498ff814c1b1efacd212e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a445e00f595ee5e2f75fc0a0e81b07"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename... Elements&gt; </td></tr>
<tr class="memitem:ab4a445e00f595ee5e2f75fc0a0e81b07"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab4a445e00f595ee5e2f75fc0a0e81b07">get</a> (<a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;tuple) -&gt; auto &amp;</td></tr>
<tr class="separator:ab4a445e00f595ee5e2f75fc0a0e81b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b641cbeb889f9a3002ae9ec9b6569c9"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename... Elements&gt; </td></tr>
<tr class="memitem:a0b641cbeb889f9a3002ae9ec9b6569c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0b641cbeb889f9a3002ae9ec9b6569c9">get</a> (const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;tuple) -&gt; const auto &amp;</td></tr>
<tr class="separator:a0b641cbeb889f9a3002ae9ec9b6569c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad527d6d304c87d6ab25d4d78e15cebc4"><td class="memTemplParams" colspan="2">template&lt;typename... ElementsA, typename... ElementsB&gt; </td></tr>
<tr class="memitem:ad527d6d304c87d6ab25d4d78e15cebc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ad527d6d304c87d6ab25d4d78e15cebc4">operator==</a> (const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsA... &gt; &amp;a, const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsB... &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:ad527d6d304c87d6ab25d4d78e15cebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c4b4fb7b3d91e88bca98224400ac32"><td class="memTemplParams" colspan="2">template&lt;typename... ElementsA, typename... ElementsB&gt; </td></tr>
<tr class="memitem:a07c4b4fb7b3d91e88bca98224400ac32"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a07c4b4fb7b3d91e88bca98224400ac32">operator!=</a> (const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsA... &gt; &amp;a, const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsB... &gt; &amp;b) -&gt; bool</td></tr>
<tr class="separator:a07c4b4fb7b3d91e88bca98224400ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42df604d705148baf4262104f6541560"><td class="memTemplParams" colspan="2">template&lt;typename Tuple1 , typename Tuple2 &gt; </td></tr>
<tr class="memitem:a42df604d705148baf4262104f6541560"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a42df604d705148baf4262104f6541560">tupleCat</a> (const Tuple1 &amp;t1, const Tuple2 &amp;t2)</td></tr>
<tr class="separator:a42df604d705148baf4262104f6541560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97abfc449e394428735699c5259f4a2"><td class="memTemplParams" colspan="2">template&lt;std::size_t Pos, typename Tuple , typename Replacement &gt; </td></tr>
<tr class="memitem:af97abfc449e394428735699c5259f4a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af97abfc449e394428735699c5259f4a2">tupleReplace</a> (<a class="el" href="structllama_1_1Tuple.html">Tuple</a> &amp;&amp;tuple, Replacement &amp;&amp;replacement)</td></tr>
<tr class="memdesc:af97abfc449e394428735699c5259f4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a tuple with the element at position Pos replaced by replacement.  <a href="namespacellama.html#af97abfc449e394428735699c5259f4a2">More...</a><br /></td></tr>
<tr class="separator:af97abfc449e394428735699c5259f4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba450a02d1e534f8cea4073bf6fda830"><td class="memTemplParams" colspan="2">template&lt;typename... Elements, typename Functor &gt; </td></tr>
<tr class="memitem:aba450a02d1e534f8cea4073bf6fda830"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aba450a02d1e534f8cea4073bf6fda830">tupleTransform</a> (const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;tuple, const Functor &amp;functor)</td></tr>
<tr class="separator:aba450a02d1e534f8cea4073bf6fda830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a49de4920182eda8ca9cf2bf57d0f9"><td class="memTemplParams" colspan="2">template&lt;typename... Elements&gt; </td></tr>
<tr class="memitem:af3a49de4920182eda8ca9cf2bf57d0f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af3a49de4920182eda8ca9cf2bf57d0f9">popFront</a> (const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:af3a49de4920182eda8ca9cf2bf57d0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the tuple without the first element.  <a href="namespacellama.html#af3a49de4920182eda8ca9cf2bf57d0f9">More...</a><br /></td></tr>
<tr class="separator:af3a49de4920182eda8ca9cf2bf57d0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a76478259d35873449cc44e27dd5abc"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename Allocator  = bloballoc::Vector, typename Accessor  = accessor::Default&gt; </td></tr>
<tr class="memitem:a1a76478259d35873449cc44e27dd5abc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1a76478259d35873449cc44e27dd5abc">allocViewUninitialized</a> (Mapping mapping={}, const Allocator &amp;alloc={}, Accessor accessor={})</td></tr>
<tr class="memdesc:a1a76478259d35873449cc44e27dd5abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="namespacellama.html#a8e5d70e7cec0c305424ed3890c4cedc6">allocView</a> but does not run field constructors.  <a href="namespacellama.html#a1a76478259d35873449cc44e27dd5abc">More...</a><br /></td></tr>
<tr class="separator:a1a76478259d35873449cc44e27dd5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0289e8c7f0657f29a2b02a1d37452493"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename BlobType , typename Accessor , std::size_t... RCs&gt; </td></tr>
<tr class="memitem:a0289e8c7f0657f29a2b02a1d37452493"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0289e8c7f0657f29a2b02a1d37452493">constructField</a> (<a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, BlobType, Accessor &gt; &amp;view, typename Mapping::ArrayExtents::Index ai, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; RCs... &gt; rc)</td></tr>
<tr class="separator:a0289e8c7f0657f29a2b02a1d37452493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c8d962f80ddc030f99b08479ecb083"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename BlobType , typename Accessor &gt; </td></tr>
<tr class="memitem:af4c8d962f80ddc030f99b08479ecb083"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af4c8d962f80ddc030f99b08479ecb083">constructFields</a> (<a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, BlobType, Accessor &gt; &amp;view)</td></tr>
<tr class="separator:af4c8d962f80ddc030f99b08479ecb083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d70e7cec0c305424ed3890c4cedc6"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename Allocator  = bloballoc::Vector, typename Accessor  = accessor::Default&gt; </td></tr>
<tr class="memitem:a8e5d70e7cec0c305424ed3890c4cedc6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a8e5d70e7cec0c305424ed3890c4cedc6">allocView</a> (Mapping mapping={}, const Allocator &amp;alloc={}, Accessor accessor={}) -&gt; <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, <a class="el" href="namespacellama_1_1internal.html#a6b703634fd8ad7364cf42588add461bc">internal::AllocatorBlobType</a>&lt; Allocator, typename Mapping::RecordDim &gt;, Accessor &gt;</td></tr>
<tr class="separator:a8e5d70e7cec0c305424ed3890c4cedc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2433706eff02aa64f1354cae4d44f14"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename RecordDim &gt; </td></tr>
<tr class="memitem:ac2433706eff02aa64f1354cae4d44f14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ac2433706eff02aa64f1354cae4d44f14">allocScalarViewUninitialized</a> () -&gt; decltype(auto)</td></tr>
<tr class="memdesc:ac2433706eff02aa64f1354cae4d44f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="namespacellama.html#a3e6032b02494ed6d889e8612fa5006dd">allocScalarView</a> but does not run field constructors.  <a href="namespacellama.html#ac2433706eff02aa64f1354cae4d44f14">More...</a><br /></td></tr>
<tr class="separator:ac2433706eff02aa64f1354cae4d44f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6032b02494ed6d889e8612fa5006dd"><td class="memTemplParams" colspan="2">template&lt;std::size_t Dim, typename RecordDim &gt; </td></tr>
<tr class="memitem:a3e6032b02494ed6d889e8612fa5006dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a3e6032b02494ed6d889e8612fa5006dd">allocScalarView</a> () -&gt; decltype(auto)</td></tr>
<tr class="separator:a3e6032b02494ed6d889e8612fa5006dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38fc0d77ddcdd41b2f2522f4c5bd24e"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename RecordCoord , typename Blobs &gt; </td></tr>
<tr class="memitem:ae38fc0d77ddcdd41b2f2522f4c5bd24e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ae38fc0d77ddcdd41b2f2522f4c5bd24e">mapToMemory</a> (Mapping &amp;mapping, typename Mapping::ArrayExtents::Index ai, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> rc, Blobs &amp;blobs) -&gt; decltype(auto)</td></tr>
<tr class="separator:ae38fc0d77ddcdd41b2f2522f4c5bd24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188282c298c3e709ff8727fafd31b24b"><td class="memTemplParams" colspan="2">template&lt;typename ViewFwd , typename TransformBlobFunc , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a188282c298c3e709ff8727fafd31b24b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a188282c298c3e709ff8727fafd31b24b">transformBlobs</a> (ViewFwd &amp;&amp;view, const TransformBlobFunc &amp;transformBlob)</td></tr>
<tr class="separator:a188282c298c3e709ff8727fafd31b24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2a40734074075e17bccd413a6f1ec1"><td class="memTemplParams" colspan="2">template&lt;typename View , typename NewBlobType  = CopyConst&lt;std::remove_reference_t&lt;View&gt;, std::byte&gt;*, typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;View&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a4d2a40734074075e17bccd413a6f1ec1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a4d2a40734074075e17bccd413a6f1ec1">shallowCopy</a> (<a class="el" href="structllama_1_1View.html">View</a> &amp;&amp;view)</td></tr>
<tr class="separator:a4d2a40734074075e17bccd413a6f1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66091f10efa162f8e81cd6081ff155bf"><td class="memTemplParams" colspan="2">template&lt;typename NewAccessor , typename ViewFwd , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a66091f10efa162f8e81cd6081ff155bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a66091f10efa162f8e81cd6081ff155bf">withAccessor</a> (ViewFwd &amp;&amp;view, NewAccessor newAccessor={})</td></tr>
<tr class="separator:a66091f10efa162f8e81cd6081ff155bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcf783207896246153d05625310971"><td class="memTemplParams" colspan="2">template&lt;typename NewMapping , typename ViewFwd , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a8bfcf783207896246153d05625310971"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a8bfcf783207896246153d05625310971">withMapping</a> (ViewFwd &amp;&amp;view, NewMapping newMapping={})</td></tr>
<tr class="separator:a8bfcf783207896246153d05625310971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08522ce66a9c0e6ac1b771e38a81d97e"><td class="memTemplParams" colspan="2">template&lt;typename TStoredParentView &gt; </td></tr>
<tr class="memitem:a08522ce66a9c0e6ac1b771e38a81d97e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a08522ce66a9c0e6ac1b771e38a81d97e">SubView</a> (TStoredParentView &amp;&amp;, typename std::remove_reference_t&lt; TStoredParentView &gt;::Mapping::ArrayExtents::Index) -&gt; <a class="el" href="structllama_1_1SubView.html">SubView</a>&lt; TStoredParentView &gt;</td></tr>
<tr class="separator:a08522ce66a9c0e6ac1b771e38a81d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1f5816e83615dc84a55b3c2e6f2a0237"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">dyn</a> = <a class="el" href="structllama_1_1internal_1_1Dyn.html">internal::Dyn</a>{}</td></tr>
<tr class="memdesc:a1f5816e83615dc84a55b3c2e6f2a0237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as a template argument to <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> to mark a dynamic extent.  <a href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">More...</a><br /></td></tr>
<tr class="separator:a1f5816e83615dc84a55b3c2e6f2a0237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e1dd12e96257f3aaf7a1ea6b9eead8"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a06e1dd12e96257f3aaf7a1ea6b9eead8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a06e1dd12e96257f3aaf7a1ea6b9eead8">isProxyReference</a> = <a class="el" href="structllama_1_1internal_1_1IsProxyReferenceImpl.html">internal::IsProxyReferenceImpl</a>&lt;R&gt;::value</td></tr>
<tr class="separator:a06e1dd12e96257f3aaf7a1ea6b9eead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca32b49e2be7c3c136e940939c531ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acca32b49e2be7c3c136e940939c531ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#acca32b49e2be7c3c136e940939c531ae">isAllowedFieldType</a> = std::is_trivially_destructible_v&lt;T&gt;</td></tr>
<tr class="memdesc:acca32b49e2be7c3c136e940939c531ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the given type is allowed as a field type in LLAMA. Such types need to be trivially constructible and trivially destructible.  <a href="namespacellama.html#acca32b49e2be7c3c136e940939c531ae">More...</a><br /></td></tr>
<tr class="separator:acca32b49e2be7c3c136e940939c531ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75482a9b4713c755f75805bd247866e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75482a9b4713c755f75805bd247866e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a75482a9b4713c755f75805bd247866e9">isField</a> = false</td></tr>
<tr class="separator:a75482a9b4713c755f75805bd247866e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026262aaccd3c32d553a96d7a56e8b3"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Type &gt; </td></tr>
<tr class="memitem:ae026262aaccd3c32d553a96d7a56e8b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ae026262aaccd3c32d553a96d7a56e8b3">isField&lt; Field&lt; Tag, Type &gt; &gt;</a> = true</td></tr>
<tr class="separator:ae026262aaccd3c32d553a96d7a56e8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2aa8fd3e43e43b830bc4a71b180175"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b2aa8fd3e43e43b830bc4a71b180175"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a3b2aa8fd3e43e43b830bc4a71b180175">isRecord</a> = false</td></tr>
<tr class="separator:a3b2aa8fd3e43e43b830bc4a71b180175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee8dc812f8d14dbea092728c88a937d"><td class="memTemplParams" colspan="2">template&lt;typename... Fields&gt; </td></tr>
<tr class="memitem:adee8dc812f8d14dbea092728c88a937d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#adee8dc812f8d14dbea092728c88a937d">isRecord&lt; Record&lt; Fields... &gt; &gt;</a> = true</td></tr>
<tr class="separator:adee8dc812f8d14dbea092728c88a937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d280955e5b9deb36f6c8fa1124ca2b"><td class="memTemplParams" colspan="2">template&lt;typename RecordDimA , typename RecordCoordA , typename RecordDimB , typename RecordCoordB &gt; </td></tr>
<tr class="memitem:a39d280955e5b9deb36f6c8fa1124ca2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a39d280955e5b9deb36f6c8fa1124ca2b">hasSameTags</a></td></tr>
<tr class="separator:a39d280955e5b9deb36f6c8fa1124ca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c960189f5edc242be631e2e8757914"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim &gt; </td></tr>
<tr class="memitem:aa6c960189f5edc242be631e2e8757914"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a> = 1</td></tr>
<tr class="memdesc:aa6c960189f5edc242be631e2e8757914"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of fields in the recursively expanded record dimension.  <a href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">More...</a><br /></td></tr>
<tr class="separator:aa6c960189f5edc242be631e2e8757914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692409342a1118048ffccba3ed1938e"><td class="memTemplParams" colspan="2">template&lt;typename... Children&gt; </td></tr>
<tr class="memitem:a9692409342a1118048ffccba3ed1938e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a9692409342a1118048ffccba3ed1938e">flatFieldCount&lt; Record&lt; Children... &gt; &gt;</a> = (<a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;<a class="el" href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">GetFieldType</a>&lt;Children&gt;&gt; + ... + 0)</td></tr>
<tr class="separator:a9692409342a1118048ffccba3ed1938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf4c61546502674c83b7e32611aca4d"><td class="memTemplParams" colspan="2">template&lt;typename Child , std::size_t N&gt; </td></tr>
<tr class="memitem:a0cf4c61546502674c83b7e32611aca4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a0cf4c61546502674c83b7e32611aca4d">flatFieldCount&lt; Child[N]&gt;</a> = <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;Child&gt; * N</td></tr>
<tr class="separator:a0cf4c61546502674c83b7e32611aca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3056b43b48f32a66160a6dd273662d"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename RecordCoord &gt; </td></tr>
<tr class="memitem:a6c3056b43b48f32a66160a6dd273662d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a> = 0</td></tr>
<tr class="separator:a6c3056b43b48f32a66160a6dd273662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ce8695c9b67882c44356056ad3156d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03ce8695c9b67882c44356056ad3156d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a03ce8695c9b67882c44356056ad3156d">flatRecordCoord&lt; T, RecordCoord&lt;&gt; &gt;</a> = 0</td></tr>
<tr class="separator:a03ce8695c9b67882c44356056ad3156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49085229ed957d67678ce1e04c704e67"><td class="memTemplParams" colspan="2">template&lt;typename... Children, std::size_t I, std::size_t... Is&gt; </td></tr>
<tr class="memitem:a49085229ed957d67678ce1e04c704e67"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a49085229ed957d67678ce1e04c704e67">flatRecordCoord&lt; Record&lt; Children... &gt;, RecordCoord&lt; I, Is... &gt; &gt;</a></td></tr>
<tr class="separator:a49085229ed957d67678ce1e04c704e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46edda82bf9ef35a2d461b77b5911f"><td class="memTemplParams" colspan="2">template&lt;typename Child , std::size_t N, std::size_t I, std::size_t... Is&gt; </td></tr>
<tr class="memitem:aef46edda82bf9ef35a2d461b77b5911f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aef46edda82bf9ef35a2d461b77b5911f">flatRecordCoord&lt; Child[N], RecordCoord&lt; I, Is... &gt; &gt;</a> = <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;Child&gt; * I + <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a>&lt;Child, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;Is...&gt;&gt;</td></tr>
<tr class="separator:aef46edda82bf9ef35a2d461b77b5911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2067ffe5979128e7efaf1fd4c35810"><td class="memTemplParams" colspan="2">template&lt;typename TypeList &gt; </td></tr>
<tr class="memitem:a6f2067ffe5979128e7efaf1fd4c35810"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a6f2067ffe5979128e7efaf1fd4c35810">flatAlignOf</a> = <a class="el" href="namespacellama_1_1internal.html#a2413ee7f2d6487f7e306148cf2b46ac4">internal::flatAlignOfImpl</a>&lt;TypeList&gt;()</td></tr>
<tr class="separator:a6f2067ffe5979128e7efaf1fd4c35810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54c80b077fb3d417466c83d0d005907"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af54c80b077fb3d417466c83d0d005907"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af54c80b077fb3d417466c83d0d005907">alignOf</a> = alignof(T)</td></tr>
<tr class="memdesc:af54c80b077fb3d417466c83d0d005907"><td class="mdescLeft">&#160;</td><td class="mdescRight">The alignment of a type T.  <a href="namespacellama.html#af54c80b077fb3d417466c83d0d005907">More...</a><br /></td></tr>
<tr class="separator:af54c80b077fb3d417466c83d0d005907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945addc7fc78f444f37bb79d099cfd84"><td class="memTemplParams" colspan="2">template&lt;typename... Fields&gt; </td></tr>
<tr class="memitem:a945addc7fc78f444f37bb79d099cfd84"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a945addc7fc78f444f37bb79d099cfd84">alignOf&lt; Record&lt; Fields... &gt; &gt;</a> = <a class="el" href="namespacellama.html#a6f2067ffe5979128e7efaf1fd4c35810">flatAlignOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;<a class="el" href="structllama_1_1Record.html">Record</a>&lt;Fields...&gt;&gt;&gt;</td></tr>
<tr class="separator:a945addc7fc78f444f37bb79d099cfd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f48517b46c35c1a511273f08d2abb3"><td class="memTemplParams" colspan="2">template&lt;typename TypeList , bool Align, bool IncludeTailPadding = true&gt; </td></tr>
<tr class="memitem:ac8f48517b46c35c1a511273f08d2abb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ac8f48517b46c35c1a511273f08d2abb3">flatSizeOf</a> = <a class="el" href="namespacellama_1_1internal.html#aeab53e4609fe07abfb6f5f2d532cd388">internal::sizeOfImpl</a>&lt;TypeList, Align, IncludeTailPadding&gt;()</td></tr>
<tr class="memdesc:ac8f48517b46c35c1a511273f08d2abb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a type list if its elements would be in a normal struct.  <a href="namespacellama.html#ac8f48517b46c35c1a511273f08d2abb3">More...</a><br /></td></tr>
<tr class="separator:ac8f48517b46c35c1a511273f08d2abb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2404e09083dc2c685bc283cd4ead0edc"><td class="memTemplParams" colspan="2">template&lt;typename T , bool Align = false, bool IncludeTailPadding = true&gt; </td></tr>
<tr class="memitem:a2404e09083dc2c685bc283cd4ead0edc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a2404e09083dc2c685bc283cd4ead0edc">sizeOf</a> = sizeof(T)</td></tr>
<tr class="memdesc:a2404e09083dc2c685bc283cd4ead0edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a type T.  <a href="namespacellama.html#a2404e09083dc2c685bc283cd4ead0edc">More...</a><br /></td></tr>
<tr class="separator:a2404e09083dc2c685bc283cd4ead0edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585d55cd3a51152ec452bc1f2d49a3ec"><td class="memTemplParams" colspan="2">template&lt;typename... Fields, bool Align, bool IncludeTailPadding&gt; </td></tr>
<tr class="memitem:a585d55cd3a51152ec452bc1f2d49a3ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a585d55cd3a51152ec452bc1f2d49a3ec">sizeOf&lt; Record&lt; Fields... &gt;, Align, IncludeTailPadding &gt;</a> = <a class="el" href="namespacellama.html#ac8f48517b46c35c1a511273f08d2abb3">flatSizeOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;<a class="el" href="structllama_1_1Record.html">Record</a>&lt;Fields...&gt;&gt;, Align, IncludeTailPadding&gt;</td></tr>
<tr class="memdesc:a585d55cd3a51152ec452bc1f2d49a3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of a record dimension if its fields would be in a normal struct.  <a href="namespacellama.html#a585d55cd3a51152ec452bc1f2d49a3ec">More...</a><br /></td></tr>
<tr class="separator:a585d55cd3a51152ec452bc1f2d49a3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b86f2441b1aae82532668e1a8377df2"><td class="memTemplParams" colspan="2">template&lt;typename TypeList , std::size_t I, bool Align&gt; </td></tr>
<tr class="memitem:a7b86f2441b1aae82532668e1a8377df2"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a7b86f2441b1aae82532668e1a8377df2">flatOffsetOf</a> = <a class="el" href="namespacellama_1_1internal.html#a8420725970ab9da75999e4dfad4e8590">internal::offsetOfImplWorkaround</a>&lt;TypeList, I, Align&gt;()</td></tr>
<tr class="memdesc:a7b86f2441b1aae82532668e1a8377df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The byte offset of an element in a type list ifs elements would be in a normal struct.  <a href="namespacellama.html#a7b86f2441b1aae82532668e1a8377df2">More...</a><br /></td></tr>
<tr class="separator:a7b86f2441b1aae82532668e1a8377df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae03df933faef61723569d4655563bbe"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , typename RecordCoord , bool Align = false&gt; </td></tr>
<tr class="memitem:aae03df933faef61723569d4655563bbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aae03df933faef61723569d4655563bbe">offsetOf</a> = <a class="el" href="namespacellama.html#a7b86f2441b1aae82532668e1a8377df2">flatOffsetOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;RecordDim&gt;, <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;, Align&gt;</td></tr>
<tr class="separator:aae03df933faef61723569d4655563bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f37f9e6c5055a9fa84709a6c5e5304"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8f37f9e6c5055a9fa84709a6c5e5304"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">isRecordDim</a> = <a class="el" href="namespacellama.html#a3b2aa8fd3e43e43b830bc4a71b180175">isRecord</a>&lt;T&gt; || <a class="el" href="structllama_1_1internal_1_1IsBoundedArray.html">internal::IsBoundedArray</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ab8f37f9e6c5055a9fa84709a6c5e5304"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the T is a record dimension. That is, T is either a <a class="el" href="structllama_1_1Record.html" title="A type list of Fields which may be used to define a record dimension.">llama::Record</a> or a bounded array.  <a href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">More...</a><br /></td></tr>
<tr class="separator:ab8f37f9e6c5055a9fa84709a6c5e5304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3261387e3af25b2f65fb3725bacde1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb3261387e3af25b2f65fb3725bacde1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aeb3261387e3af25b2f65fb3725bacde1">isConstant</a> = <a class="el" href="structllama_1_1internal_1_1IsConstant.html">internal::IsConstant</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aeb3261387e3af25b2f65fb3725bacde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548294a2b7b4f2e76954d9cf9edcdec7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a548294a2b7b4f2e76954d9cf9edcdec7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a548294a2b7b4f2e76954d9cf9edcdec7">isRecordCoord</a> = false</td></tr>
<tr class="separator:a548294a2b7b4f2e76954d9cf9edcdec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c898b6940a90559b91b4057b85fb74b"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Coords&gt; </td></tr>
<tr class="memitem:a9c898b6940a90559b91b4057b85fb74b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a9c898b6940a90559b91b4057b85fb74b">isRecordCoord&lt; RecordCoord&lt; Coords... &gt; &gt;</a> = true</td></tr>
<tr class="separator:a9c898b6940a90559b91b4057b85fb74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8660330eb77e8654033787e86b8da6ed"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second &gt; </td></tr>
<tr class="memitem:a8660330eb77e8654033787e86b8da6ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a8660330eb77e8654033787e86b8da6ed">recordCoordCommonPrefixIsBigger</a> = <a class="el" href="namespacellama_1_1internal.html#a02e115f3c9d3acdccd07526d475ed358">internal::recordCoordCommonPrefixIsBiggerImpl</a>(First{}, Second{})</td></tr>
<tr class="memdesc:a8660330eb77e8654033787e86b8da6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wether the first <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> is bigger than the second.  <a href="namespacellama.html#a8660330eb77e8654033787e86b8da6ed">More...</a><br /></td></tr>
<tr class="separator:a8660330eb77e8654033787e86b8da6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50289a09b368b8f1c333e3d6feb49398"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second &gt; </td></tr>
<tr class="memitem:a50289a09b368b8f1c333e3d6feb49398"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a50289a09b368b8f1c333e3d6feb49398">recordCoordCommonPrefixIsSame</a> = <a class="el" href="namespacellama_1_1internal.html#a5732c14ad8045af3e542cf23a7e82c6d">internal::recordCoordCommonPrefixIsSameImpl</a>(First{}, Second{})</td></tr>
<tr class="memdesc:a50289a09b368b8f1c333e3d6feb49398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s are the same or one is the prefix of the other.  <a href="namespacellama.html#a50289a09b368b8f1c333e3d6feb49398">More...</a><br /></td></tr>
<tr class="separator:a50289a09b368b8f1c333e3d6feb49398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3acf31ae1481251861f38e12ee58dda"><td class="memTemplParams" colspan="2">template&lt;typename View &gt; </td></tr>
<tr class="memitem:af3acf31ae1481251861f38e12ee58dda"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#af3acf31ae1481251861f38e12ee58dda">isRecordRef</a> = false</td></tr>
<tr class="separator:af3acf31ae1481251861f38e12ee58dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88abd408b8ac8bd2456a8316a62a5928"><td class="memTemplParams" colspan="2">template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </td></tr>
<tr class="memitem:a88abd408b8ac8bd2456a8316a62a5928"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a88abd408b8ac8bd2456a8316a62a5928">isRecordRef&lt; RecordRef&lt; View, BoundRecordCoord, OwnView &gt; &gt;</a> = true</td></tr>
<tr class="separator:a88abd408b8ac8bd2456a8316a62a5928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e41b88e239189c88b2d895bfc2691e"><td class="memTemplParams" colspan="2">template&lt;typename Simd , typename SFINAE  = void&gt; </td></tr>
<tr class="memitem:a85e41b88e239189c88b2d895bfc2691e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a85e41b88e239189c88b2d895bfc2691e">simdLanes</a> = <a class="el" href="structllama_1_1SimdTraits.html">SimdTraits</a>&lt;<a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a>&gt;::lanes</td></tr>
<tr class="separator:a85e41b88e239189c88b2d895bfc2691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f90853e28950fdd34ecf9696ae1f63"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </td></tr>
<tr class="memitem:a34f90853e28950fdd34ecf9696ae1f63"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a34f90853e28950fdd34ecf9696ae1f63">simdLanesWithFullVectorsFor</a> = <a class="el" href="namespacellama.html#abb21e8bcb7c41613b7183a1beef1f600">chooseSimdLanes</a>&lt;RecordDim, MakeSimd&gt;([](auto a, auto b) { return std::max(a, b); })</td></tr>
<tr class="separator:a34f90853e28950fdd34ecf9696ae1f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac902aa26f43ee2c8cceeb580a1df0c50"><td class="memTemplParams" colspan="2">template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </td></tr>
<tr class="memitem:ac902aa26f43ee2c8cceeb580a1df0c50"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#ac902aa26f43ee2c8cceeb580a1df0c50">simdLanesWithLeastRegistersFor</a> = <a class="el" href="namespacellama.html#abb21e8bcb7c41613b7183a1beef1f600">chooseSimdLanes</a>&lt;RecordDim, MakeSimd&gt;([](auto a, auto b) { return std::min(a, b); })</td></tr>
<tr class="separator:ac902aa26f43ee2c8cceeb580a1df0c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d7068ee2176f6a3bbd750665ac5af0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06d7068ee2176f6a3bbd750665ac5af0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a06d7068ee2176f6a3bbd750665ac5af0">qualifiedTypeName</a></td></tr>
<tr class="separator:a06d7068ee2176f6a3bbd750665ac5af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9676a3903b134df116791bcae533d6c6"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename RecordCoord &gt; </td></tr>
<tr class="memitem:a9676a3903b134df116791bcae533d6c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a9676a3903b134df116791bcae533d6c6">isComputed</a> = <a class="el" href="structllama_1_1internal_1_1IsComputed.html">internal::IsComputed</a>&lt;Mapping, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;::value</td></tr>
<tr class="memdesc:a9676a3903b134df116791bcae533d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the field accessed via the given mapping and record coordinate is a computed value.  <a href="namespacellama.html#a9676a3903b134df116791bcae533d6c6">More...</a><br /></td></tr>
<tr class="separator:a9676a3903b134df116791bcae533d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156385d5598b772070206225a5093266"><td class="memTemplParams" colspan="2">template&lt;typename Mapping &gt; </td></tr>
<tr class="memitem:a156385d5598b772070206225a5093266"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a156385d5598b772070206225a5093266">hasAnyComputedField</a></td></tr>
<tr class="memdesc:a156385d5598b772070206225a5093266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any field accessed via the given mapping is a computed value.  <a href="namespacellama.html#a156385d5598b772070206225a5093266">More...</a><br /></td></tr>
<tr class="separator:a156385d5598b772070206225a5093266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf6a2d8f8fd3cde95667fbf433e42d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecf6a2d8f8fd3cde95667fbf433e42d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#aecf6a2d8f8fd3cde95667fbf433e42d1">isOne</a> = false</td></tr>
<tr class="memdesc:aecf6a2d8f8fd3cde95667fbf433e42d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is true, if T is an instance of <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>.  <a href="namespacellama.html#aecf6a2d8f8fd3cde95667fbf433e42d1">More...</a><br /></td></tr>
<tr class="separator:aecf6a2d8f8fd3cde95667fbf433e42d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aec444f97e67c053400d58fae4126b"><td class="memTemplParams" colspan="2">template&lt;typename View , typename BoundRecordCoord &gt; </td></tr>
<tr class="memitem:a44aec444f97e67c053400d58fae4126b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a44aec444f97e67c053400d58fae4126b">isOne&lt; RecordRef&lt; View, BoundRecordCoord, true &gt; &gt;</a> = true</td></tr>
<tr class="separator:a44aec444f97e67c053400d58fae4126b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3ef24f7ab0d71912a5f7e71cf24130"><td class="memTemplParams" colspan="2">template&lt;typename View &gt; </td></tr>
<tr class="memitem:a2c3ef24f7ab0d71912a5f7e71cf24130"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#a2c3ef24f7ab0d71912a5f7e71cf24130">isView</a> = false</td></tr>
<tr class="separator:a2c3ef24f7ab0d71912a5f7e71cf24130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abada4e4a295e9cacca30c9bebd6f5dbf"><td class="memTemplParams" colspan="2">template&lt;typename Mapping , typename BlobType , typename Accessor &gt; </td></tr>
<tr class="memitem:abada4e4a295e9cacca30c9bebd6f5dbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellama.html#abada4e4a295e9cacca30c9bebd6f5dbf">isView&lt; View&lt; Mapping, BlobType, Accessor &gt; &gt;</a> = true</td></tr>
<tr class="separator:abada4e4a295e9cacca30c9bebd6f5dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a224063aae62355b61616e5d59c8e8517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224063aae62355b61616e5d59c8e8517">&#9670;&nbsp;</a></span>ArrayExtentsDynamic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a224063aae62355b61616e5d59c8e8517">llama::ArrayExtentsDynamic</a> = typedef <a class="el" href="namespacellama.html#a4611a0c2dd8c34c55b8a72da6da7ace2">ArrayExtentsNCube</a>&lt;SizeType, N, <a class="el" href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">dyn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>N-dimensional <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> where all values are dynamic. </p>

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00246">246</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a4611a0c2dd8c34c55b8a72da6da7ace2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4611a0c2dd8c34c55b8a72da6da7ace2">&#9670;&nbsp;</a></span>ArrayExtentsNCube</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , std::size_t N, SizeType Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a4611a0c2dd8c34c55b8a72da6da7ace2">llama::ArrayExtentsNCube</a> = typedef decltype(<a class="el" href="namespacellama_1_1internal.html#aa53f8a0b5fadc80cbc91b1b8a1d7633c">internal::makeArrayExtents</a>&lt;SizeType, Extent&gt;(std::make_index_sequence&lt;N&gt;{}))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>N-dimensional <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> where all N extents are Extent. </p>

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00241">241</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="aca92a835e40a98002ba3b05c050d00cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca92a835e40a98002ba3b05c050d00cf">&#9670;&nbsp;</a></span>Cat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... RecordCoords&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#aca92a835e40a98002ba3b05c050d00cf">llama::Cat</a> = typedef <a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">RecordCoordFromList</a>&lt;mp_append&lt;typename RecordCoords::List...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate a set of <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00116">116</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a0af0304a902bcb5c5c90377ad751033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af0304a902bcb5c5c90377ad751033a">&#9670;&nbsp;</a></span>Constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a0af0304a902bcb5c5c90377ad751033a">llama::Constant</a> = typedef std::integral_constant&lt;decltype(V), V&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used as template argument to specify a constant/compile-time value. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00829">829</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aa7d11eb31b39aeb9471429ced9d7a484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d11eb31b39aeb9471429ced9d7a484">&#9670;&nbsp;</a></span>CopyConst</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FromT , typename ToT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#aa7d11eb31b39aeb9471429ced9d7a484">llama::CopyConst</a> = typedef std::conditional_t&lt;std::is_const_v&lt;FromT&gt;, const ToT, ToT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for ToT, adding <code>const</code> if FromT is const qualified. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00824">824</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a1fddf1f638927edfb8da8e3c78da4e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fddf1f638927edfb8da8e3c78da4e1c">&#9670;&nbsp;</a></span>FlatRecordDim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">llama::FlatRecordDim</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1FlattenRecordDimImpl.html">internal::FlattenRecordDimImpl</a>&lt;RecordDim&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a flat type list containing all leaf field types of the given record dimension. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00481">481</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ac1474c16fc91cddf593cb83ac1234619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1474c16fc91cddf593cb83ac1234619">&#9670;&nbsp;</a></span>GetCoordFromTags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename... TagsOrTagList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#ac1474c16fc91cddf593cb83ac1234619">llama::GetCoordFromTags</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1GetCoordFromTagsImpl.html">internal::GetCoordFromTagsImpl</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, TagsOrTagList...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a series of tags, or a list of tags, navigating down a record dimension into a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>. A <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> will be passed through unmodified. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00352">352</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aca81dc9a7fe8571b47958428e8bfe231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca81dc9a7fe8571b47958428e8bfe231">&#9670;&nbsp;</a></span>GetFieldTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#aca81dc9a7fe8571b47958428e8bfe231">llama::GetFieldTag</a> = typedef mp_first&lt;<a class="el" href="structllama_1_1Field.html">Field</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tag from a <a class="el" href="structllama_1_1Field.html">Field</a>. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00186">186</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a75dfd56127d13358c2991a57340657dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dfd56127d13358c2991a57340657dc">&#9670;&nbsp;</a></span>GetFieldType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Field &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">llama::GetFieldType</a> = typedef mp_second&lt;<a class="el" href="structllama_1_1Field.html">Field</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type from a <a class="el" href="structllama_1_1Field.html">Field</a>. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00191">191</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a5c9a9464eb5c520170ea7911bac60863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9a9464eb5c520170ea7911bac60863">&#9670;&nbsp;</a></span>GetTag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename RecordCoord &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a5c9a9464eb5c520170ea7911bac60863">llama::GetTag</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1GetTagImpl.html">internal::GetTagImpl</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tag of the <a class="el" href="structllama_1_1Field.html">Field</a> at a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> inside the record dimension tree. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00253">253</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a4a4fd33218cce7b2e592486d80f2ae90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4fd33218cce7b2e592486d80f2ae90">&#9670;&nbsp;</a></span>GetTags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename RecordCoord &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a4a4fd33218cce7b2e592486d80f2ae90">llama::GetTags</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1GetTagsImpl.html">internal::GetTagsImpl</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the tags of all <a class="el" href="structllama_1_1Field.html">Field</a>s from the root of the record dimension tree until to the node identified by <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00233">233</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="acdfb627d325de5ab6c18cdc842cd7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfb627d325de5ab6c18cdc842cd7350">&#9670;&nbsp;</a></span>GetType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename... RecordCoordOrTags&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#acdfb627d325de5ab6c18cdc842cd7350">llama::GetType</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1GetTypeImpl.html">internal::GetTypeImpl</a>&lt;RecordDim, RecordCoordOrTags...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of a node in a record dimension tree identified by a given <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> or a series of tags. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00387">387</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ab0c1ac83b09aa8a960eca20d2aea3a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c1ac83b09aa8a960eca20d2aea3a98">&#9670;&nbsp;</a></span>LeafRecordCoords</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#ab0c1ac83b09aa8a960eca20d2aea3a98">llama::LeafRecordCoords</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1LeafRecordCoordsImpl.html">internal::LeafRecordCoordsImpl</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a flat type list containing all record coordinates to all leaves of the given record dimension. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00427">427</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ab77dc388b0806851df1b1834ad4a31e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77dc388b0806851df1b1834ad4a31e0">&#9670;&nbsp;</a></span>MergedRecordDims</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDimA , typename RecordDimB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#ab77dc388b0806851df1b1834ad4a31e0">llama::MergedRecordDims</a> = typedef typename decltype(<a class="el" href="namespacellama_1_1internal.html#ab4ccd5eb73c48197b867b5fe4c98c55f">internal::mergeRecordDimsImpl</a>(mp_identity&lt;RecordDimA&gt;{}, mp_identity&lt;RecordDimB&gt;{}))::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a merged record dimension, where duplicated, nested fields are unified. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00818">818</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a7b33b2c30fa081e8352cf12c7b98b0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b33b2c30fa081e8352cf12c7b98b0eb">&#9670;&nbsp;</a></span>One</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">llama::One</a> = typedef <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt;decltype(<a class="el" href="namespacellama.html#a3e6032b02494ed6d889e8612fa5006dd">allocScalarView</a>&lt;0, RecordDim&gt;()), <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a> that owns and holds a single value. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00193">193</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a51dcbb30751c7c23e97d434736a0acc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dcbb30751c7c23e97d434736a0acc4">&#9670;&nbsp;</a></span>PopFront</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordCoord &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a51dcbb30751c7c23e97d434736a0acc4">llama::PopFront</a> = typedef <a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">RecordCoordFromList</a>&lt;mp_pop_front&lt;typename <a class="el" href="structllama_1_1RecordCoord.html#a685a368d5b00931fb77af19012b10b4b">RecordCoord::List</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> without first coordinate component. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00129">129</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="ad95912a49a83091fde091a4e2d9a4118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95912a49a83091fde091a4e2d9a4118">&#9670;&nbsp;</a></span>RecordCoordFromList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#ad95912a49a83091fde091a4e2d9a4118">llama::RecordCoordFromList</a> = typedef <a class="el" href="namespacellama_1_1internal.html#a81e3783dd94e3a1b003f955aaacf49d6">internal::mp_unwrap_values_into</a>&lt;L, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a type list of integral constants into a <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00111">111</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a533ad08f0a1fa09005088a13a6b59040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533ad08f0a1fa09005088a13a6b59040">&#9670;&nbsp;</a></span>ReplacePlaceholders</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expression , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a533ad08f0a1fa09005088a13a6b59040">llama::ReplacePlaceholders</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1ReplacePlaceholdersImpl.html">internal::ReplacePlaceholdersImpl</a>&lt;Expression, Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Meta_8hpp_source.html#l00057">57</a> of file <a class="el" href="Meta_8hpp_source.html">Meta.hpp</a>.</p>

</div>
</div>
<a id="adf42387a56b588d4a261b9ab869e33ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf42387a56b588d4a261b9ab869e33ee">&#9670;&nbsp;</a></span>Simd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename &gt; typename MakeSimd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">llama::Simd</a> = typedef typename std:: conditional_t&lt;<a class="el" href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">isRecordDim</a>&lt;T&gt;, mp_identity&lt;<a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt;<a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">Simdize</a>&lt;T, MakeSimd&gt; &gt;&gt;, mp_identity&lt;<a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">Simdize</a>&lt;T, MakeSimd&gt; &gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a SIMD version of the given type. Of T is a record dimension, creates a <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> where each field is a SIMD type of the original field type. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00166">166</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="adf54146d2fef06baf9d512e22793f41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf54146d2fef06baf9d512e22793f41a">&#9670;&nbsp;</a></span>Simdize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#adf54146d2fef06baf9d512e22793f41a">llama::Simdize</a> = typedef <a class="el" href="namespacellama.html#a825425dc4761ab3b27c3ec6d42876f32">TransformLeaves</a>&lt;RecordDim, MakeSimd&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the given record dimension into a SIMD version of it. Each leaf field type will be replaced by a SIMD vector, as determined by MakeSimd. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00149">149</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="ab5050ae091b407bcd3adabb734f2aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5050ae091b407bcd3adabb734f2aba0">&#9670;&nbsp;</a></span>SimdizeN</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">llama::SimdizeN</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1SimdizeNImpl.html">internal::SimdizeNImpl</a>&lt;RecordDim, N, MakeSizedSimd&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the given record dimension into a SIMD version of it. Each leaf field type will be replaced by a sized SIMD vector with length N, as determined by MakeSizedSimd. If N is 1, SimdizeN&lt;T, 1, ...&gt; is an alias for T. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00143">143</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a2f1e01829ca6b6d3a50720fdbcc99adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1e01829ca6b6d3a50720fdbcc99adf">&#9670;&nbsp;</a></span>SimdN</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a2f1e01829ca6b6d3a50720fdbcc99adf">llama::SimdN</a> = typedef typename std::conditional_t&lt; <a class="el" href="namespacellama.html#ab8f37f9e6c5055a9fa84709a6c5e5304">isRecordDim</a>&lt;T&gt;, std::conditional_t&lt;N == 1, mp_identity&lt;<a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt;T&gt; &gt;, mp_identity&lt;<a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>&lt;<a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">SimdizeN</a>&lt;T, N, MakeSizedSimd&gt; &gt;&gt; &gt;, std::conditional_t&lt;N == 1, mp_identity&lt;T&gt;, mp_identity&lt;<a class="el" href="namespacellama.html#ab5050ae091b407bcd3adabb734f2aba0">SimdizeN</a>&lt;T, N, MakeSizedSimd&gt; &gt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a SIMD version of the given type. Of T is a record dimension, creates a <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> where each field is a SIMD type of the original field type. The SIMD vectors have length N. If N is 1, an ordinary <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> of the record dimension T is created. If T is not a record dimension, a SIMD vector with value T and length N is created. If N is 1 (and T is not a record dimension), then T is produced. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00157">157</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a825425dc4761ab3b27c3ec6d42876f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825425dc4761ab3b27c3ec6d42876f32">&#9670;&nbsp;</a></span>TransformLeaves</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename &gt; typename FieldTypeFunctor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#a825425dc4761ab3b27c3ec6d42876f32">llama::TransformLeaves</a> = typedef <a class="el" href="namespacellama.html#aaee3ebd8a4ac86fffc2c6e5cc1a3ac71">TransformLeavesWithCoord</a>&lt;RecordDim, <a class="el" href="structllama_1_1internal_1_1MakePassSecond.html">internal::MakePassSecond</a>&lt;FieldTypeFunctor&gt;::template fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new record dimension where each new leaf field's type is the result of applying FieldTypeFunctor to the original leaf field's type. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00757">757</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aaee3ebd8a4ac86fffc2c6e5cc1a3ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee3ebd8a4ac86fffc2c6e5cc1a3ac71">&#9670;&nbsp;</a></span>TransformLeavesWithCoord</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename, typename &gt; typename FieldTypeFunctor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellama.html#aaee3ebd8a4ac86fffc2c6e5cc1a3ac71">llama::TransformLeavesWithCoord</a> = typedef typename <a class="el" href="structllama_1_1internal_1_1TransformLeavesWithCoordImpl.html">internal::TransformLeavesWithCoordImpl</a>&lt;<a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;, RecordDim, FieldTypeFunctor&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new record dimension where each new leaf field's type is the result of applying FieldTypeFunctor to the original leaf's <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> and field's type. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00750">750</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3e6032b02494ed6d889e8612fa5006dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6032b02494ed6d889e8612fa5006dd">&#9670;&nbsp;</a></span>allocScalarView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename RecordDim &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::allocScalarView </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a <a class="el" href="structllama_1_1View.html">View</a> holding a single record backed by a byte array (<a class="el" href="structllama_1_1bloballoc_1_1Array.html">bloballoc::Array</a>). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dim</td><td>Dimension of the <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> of the <a class="el" href="structllama_1_1View.html">View</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00179">179</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="ac2433706eff02aa64f1354cae4d44f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2433706eff02aa64f1354cae4d44f14">&#9670;&nbsp;</a></span>allocScalarViewUninitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename RecordDim &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::allocScalarViewUninitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="namespacellama.html#a3e6032b02494ed6d889e8612fa5006dd">allocScalarView</a> but does not run field constructors. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00169">169</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a8e5d70e7cec0c305424ed3890c4cedc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d70e7cec0c305424ed3890c4cedc6">&#9670;&nbsp;</a></span>allocView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename Allocator  = bloballoc::Vector, typename Accessor  = accessor::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::allocView </td>
          <td>(</td>
          <td class="paramtype">Mapping&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structllama_1_1View.html">View</a>&lt;Mapping, <a class="el" href="namespacellama_1_1internal.html#a6b703634fd8ad7364cf42588add461bc">internal::AllocatorBlobType</a>&lt;Allocator, typename Mapping::RecordDim&gt;, Accessor&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a view based on the given mapping, e.g. AoS or :SoA. For allocating the view's underlying memory, the specified allocator callable is used (or the default one, which is <a class="el" href="structllama_1_1bloballoc_1_1Vector.html">bloballoc::Vector</a>). The allocator callable is called with the alignment and size of bytes to allocate for each blob of the mapping. Value-initialization is performed for all fields by calling <a class="el" href="namespacellama.html#af4c8d962f80ddc030f99b08479ecb083">constructFields</a>. This function is the preferred way to create a <a class="el" href="structllama_1_1View.html">View</a>. See also <a class="el" href="namespacellama.html#a1a76478259d35873449cc44e27dd5abc">allocViewUninitialized</a>. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00158">158</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a1a76478259d35873449cc44e27dd5abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a76478259d35873449cc44e27dd5abc">&#9670;&nbsp;</a></span>allocViewUninitialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename Allocator  = bloballoc::Vector, typename Accessor  = accessor::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::allocViewUninitialized </td>
          <td>(</td>
          <td class="paramtype">Mapping&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&#160;</td>
          <td class="paramname"><em>accessor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="namespacellama.html#a8e5d70e7cec0c305424ed3890c4cedc6">allocView</a> but does not run field constructors. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00055">55</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="abaefce711ff5d4566ea761ef08fab469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaefce711ff5d4566ea761ef08fab469">&#9670;&nbsp;</a></span>aosoaCommonBlockCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::aosoaCommonBlockCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AoSoA copy strategy which transfers data in common blocks. SoA mappings are also allowed for at most 1 argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadId</td><td>Optional. Zero-based id of calling thread for multi-threaded invocations. </td></tr>
    <tr><td class="paramname">threadCount</td><td>Optional. Thread count in case of multi-threaded invocation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Copy_8hpp_source.html#l00189">189</a> of file <a class="el" href="Copy_8hpp_source.html">Copy.hpp</a>.</p>

</div>
</div>
<a id="a690689d38b43930430e58bb7fe17aca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690689d38b43930430e58bb7fe17aca7">&#9670;&nbsp;</a></span>Array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1Array.html">llama::Array</a> </td>
          <td>(</td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structllama_1_1Array.html">Array</a>&lt; First, sizeof...(Args)+1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fccafcd85a44696a4d5e6659927b634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fccafcd85a44696a4d5e6659927b634">&#9670;&nbsp;</a></span>ArrayExtents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1ArrayExtents.html">llama::ArrayExtents</a> </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1IndexTypeFromArgs.html">internal::IndexTypeFromArgs</a>&lt; std::size_t, Args... &gt;::type,(Args{}, <a class="el" href="namespacellama.html#a1f5816e83615dc84a55b3c2e6f2a0237">dyn</a>)... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0fda5486eb5976f940a638f0cdd9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0fda5486eb5976f940a638f0cdd9d4">&#9670;&nbsp;</a></span>ArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1ArrayIndex.html">llama::ArrayIndex</a> </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1IndexTypeFromArgs.html">internal::IndexTypeFromArgs</a>&lt; std::size_t, Args... &gt;::type, sizeof...(Args)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42cdd926d98388052f028ab19c94b649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cdd926d98388052f028ab19c94b649">&#9670;&nbsp;</a></span>cat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... RecordCoords&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::cat </td>
          <td>(</td>
          <td class="paramtype">RecordCoords...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate a set of <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s instances. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00121">121</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="abb21e8bcb7c41613b7183a1beef1f600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21e8bcb7c41613b7183a1beef1f600">&#9670;&nbsp;</a></span>chooseSimdLanes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd, typename BinaryReductionFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::chooseSimdLanes </td>
          <td>(</td>
          <td class="paramtype">BinaryReductionFunction&#160;</td>
          <td class="paramname"><em>reduce</em></td><td>)</td>
          <td> -&gt; std::size_t
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Chooses the number of SIMD lanes for the given record dimension by mapping each field type to a SIMD type and then reducing their sizes. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MakeSimd</td><td>Type function creating a SIMD type given a field type from the record dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reduce</td><td>Binary reduction function to reduce the SIMD lanes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00078">78</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a0289e8c7f0657f29a2b02a1d37452493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0289e8c7f0657f29a2b02a1d37452493">&#9670;&nbsp;</a></span>constructField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename BlobType , typename Accessor , std::size_t... RCs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::constructField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, BlobType, Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Mapping::ArrayExtents::Index&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; RCs... &gt;&#160;</td>
          <td class="paramname"><em>rc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00096">96</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="af4c8d962f80ddc030f99b08479ecb083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c8d962f80ddc030f99b08479ecb083">&#9670;&nbsp;</a></span>constructFields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename BlobType , typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::constructFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, BlobType, Accessor &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Value-initializes all fields reachable through the given view. That is, constructors are run and fundamental types are zero-initialized. Computed fields are constructed if they return l-value references and assigned a default constructed value if they return a proxy reference. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00137">137</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="ab67a5448cc031309dc1aa8580b7d4950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67a5448cc031309dc1aa8580b7d4950">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structllama_1_1Copy.html" title="Generic implementation of copy defaulting to fieldWiseCopy. LLAMA provides several specializations of...">Copy</a> data from source to destination view. Both views need to have the same array and record dimensions, but may have different mappings. The blobs need to be read- and writeable. Delegates to <a class="el" href="structllama_1_1Copy.html">Copy</a> to choose an implementation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadId</td><td>Optional. Zero-based id of calling thread for multi-threaded invocations. </td></tr>
    <tr><td class="paramname">threadCount</td><td>Optional. Thread count in case of multi-threaded invocation. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Copy_8hpp_source.html#l00506">506</a> of file <a class="el" href="Copy_8hpp_source.html">Copy.hpp</a>.</p>

</div>
</div>
<a id="a2f41c329ce5acee2de376b6640afcbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f41c329ce5acee2de376b6640afcbe8">&#9670;&nbsp;</a></span>copyBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename SrcBlob , typename DstBlob , typename BlobCopyFunc  = decltype(internal::copyBlobWithMemcpy)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::copyBlobs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, SrcBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, DstBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlobCopyFunc&#160;</td>
          <td class="paramname"><em>copyBlob</em> = <code><a class="el" href="namespacellama_1_1internal.html#a1c6df394c66fe2b06db0c0ad6a5e7b12">internal::copyBlobWithMemcpy</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structllama_1_1Copy.html" title="Generic implementation of copy defaulting to fieldWiseCopy. LLAMA provides several specializations of...">Copy</a> the blobs' content from the source view to the destination view. Both views need to have the same mapping, and thus the same blob count and blob sizes. The copy is performed blob by blob. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyBlob</td><td>The function to use for copying blobs. Default is <a class="el" href="namespacellama_1_1internal.html#a1c6df394c66fe2b06db0c0ad6a5e7b12">internal::copyBlobWithMemcpy</a>, which uses std::memcpy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Copy_8hpp_source.html#l00101">101</a> of file <a class="el" href="Copy_8hpp_source.html">Copy.hpp</a>.</p>

</div>
</div>
<a id="a4fca680f97ca52a42cd74519e6347395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca680f97ca52a42cd74519e6347395">&#9670;&nbsp;</a></span>copyRecord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::copyRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, OwnView &gt; &amp;&#160;</td>
          <td class="paramname"><em>rr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a> with the same record dimension as the given record ref, with values copyied from rr. </p>

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00033">33</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a0f8572ce32d64cda19cb705d78247bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8572ce32d64cda19cb705d78247bed">&#9670;&nbsp;</a></span>decayCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::decayCopy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>valueOrRef</em></td><td>)</td>
          <td> -&gt; typename <a class="el" href="structllama_1_1internal_1_1ValueOf.html">internal::ValueOf</a>&lt;T&gt;::type
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulls a copy of the given value or reference. Proxy references are resolved to their value types. </p>

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00877">877</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a516c8260631ec1b61a52f0e56dc58ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516c8260631ec1b61a52f0e56dc58ac7">&#9670;&nbsp;</a></span>divCeil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::divCeil </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Integral
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ceiling of a / b. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00570">570</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a672915c49821a718f5dfa5d4540c4192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672915c49821a718f5dfa5d4540c4192">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::dot </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00325">325</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="af977754d689a5f3cc10fd80d4b37ba1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af977754d689a5f3cc10fd80d4b37ba1f">&#9670;&nbsp;</a></span>fieldWiseCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcMapping , typename SrcBlob , typename DstMapping , typename DstBlob &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::fieldWiseCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1View.html">View</a>&lt; SrcMapping, SrcBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; DstMapping, DstBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Field-wise copy from source to destination view. Both views need to have the same array and record dimensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadId</td><td>Optional. Thread id in case of multi-threaded copy. </td></tr>
    <tr><td class="paramname">threadCount</td><td>Optional. Thread count in case of multi-threaded copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Copy_8hpp_source.html#l00118">118</a> of file <a class="el" href="Copy_8hpp_source.html">Copy.hpp</a>.</p>

</div>
</div>
<a id="a1abf3984cdb9b597c147f06626114575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abf3984cdb9b597c147f06626114575">&#9670;&nbsp;</a></span>forEachArrayIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , std::size_t Dim, typename Func , typename... OuterIndices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::forEachArrayIndex </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; SizeType, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OuterIndices...&#160;</td>
          <td class="paramname"><em>outerIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00250">250</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a372264ea5e1f1bbbd0d89ffd5a9a77a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372264ea5e1f1bbbd0d89ffd5a9a77a2">&#9670;&nbsp;</a></span>forEachArrayIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , SizeType... Sizes, typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::forEachArrayIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeType, Sizes... &gt;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00271">271</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="aacc8837b94b46c9989ce0e7fe8c172ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc8837b94b46c9989ce0e7fe8c172ac">&#9670;&nbsp;</a></span>forEachLeaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordRefFwd , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void llama::forEachLeaf </td>
          <td>(</td>
          <td class="paramtype">RecordRefFwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>vr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00833">833</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a91f5d2462d07fc7d5cfa0dac05946c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f5d2462d07fc7d5cfa0dac05946c63">&#9670;&nbsp;</a></span>forEachLeafCoord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename Functor , std::size_t... Coords&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void llama::forEachLeafCoord </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;&#160;</td>
          <td class="paramname"><em>baseCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterates over the record dimension tree and calls a functor on each element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>Functor to execute at each element of. Needs to have <code>operator()</code> with a template parameter for the <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> in the record dimension tree. </td></tr>
    <tr><td class="paramname">baseCoord</td><td><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> at which the iteration should be started. The functor is called on elements beneath this coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00436">436</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a28ad5ce29085756570effc3b27378a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ad5ce29085756570effc3b27378a5c">&#9670;&nbsp;</a></span>forEachLeafCoord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename Functor , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void llama::forEachLeafCoord </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tags...&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterates over the record dimension tree and calls a functor on each element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>Functor to execute at each element of. Needs to have <code>operator()</code> with a template parameter for the <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> in the record dimension tree. </td></tr>
    <tr><td class="paramname">baseTags</td><td>Tags used to define where the iteration should be started. The functor is called on elements beneath this coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00453">453</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a0b641cbeb889f9a3002ae9ec9b6569c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b641cbeb889f9a3002ae9ec9b6569c9">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename... Elements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td> -&gt; const auto&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00130">130</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="ab4a445e00f595ee5e2f75fc0a0e81b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a445e00f595ee5e2f75fc0a0e81b07">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, typename... Elements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td> -&gt; auto&amp;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00121">121</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="a6060f4836e56bda4689232f0d22fecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6060f4836e56bda4689232f0d22fecf8">&#9670;&nbsp;</a></span>loadSimd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Simd &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::loadSimd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>srcRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> &amp;&#160;</td>
          <td class="paramname"><em>dstSimd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads SIMD vectors of data starting from the given record reference to dstSimd. Only field tags occurring in <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a> are loaded. If Simd contains multiple fields of SIMD types, a SIMD vector will be fetched for each of the fields. The number of elements fetched per SIMD vector depends on the SIMD width of the vector. Simd is allowed to have different vector lengths per element. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00308">308</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a32bf07b53ebc403eee401038fc95b591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bf07b53ebc403eee401038fc95b591">&#9670;&nbsp;</a></span>mapsPiecewiseContiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t PieceLength, typename Mapping &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::mapsPiecewiseContiguous </td>
          <td>(</td>
          <td class="paramtype">const Mapping &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Proofs by exhaustion of the array and record dimensions, that at least PieceLength elements are always stored contiguously. </p>

<p class="definition">Definition at line <a class="el" href="Proofs_8hpp_source.html#l00093">93</a> of file <a class="el" href="Proofs_8hpp_source.html">Proofs.hpp</a>.</p>

</div>
</div>
<a id="ae38fc0d77ddcdd41b2f2522f4c5bd24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38fc0d77ddcdd41b2f2522f4c5bd24e">&#9670;&nbsp;</a></span>mapToMemory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename RecordCoord , typename Blobs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::mapToMemory </td>
          <td>(</td>
          <td class="paramtype">Mapping &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Mapping::ArrayExtents::Index&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&#160;</td>
          <td class="paramname"><em>rc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Blobs &amp;&#160;</td>
          <td class="paramname"><em>blobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(auto)
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Using a mapping, maps the given array index and record coordinate to a memory reference onto the given blobs. </p><dl class="section return"><dt>Returns</dt><dd>Either an l-value reference if the record coord maps to a physical field or a proxy reference if mapped to a computed field. </dd></dl>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00364">364</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a4959ae52801ba64e6f6c3ba612de29b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4959ae52801ba64e6f6c3ba612de29b7">&#9670;&nbsp;</a></span>memcpyBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename SrcBlob , typename DstBlob , typename MemcpyFunc  = decltype(internal::memcpy)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::memcpyBlobs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, SrcBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, DstBlob &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>threadCount</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemcpyFunc&#160;</td>
          <td class="paramname"><em>singleThreadMemcpy</em> = <code><a class="el" href="namespacellama_1_1internal.html#ae7d043343c1a60a7ceb75ba7c06e4c18">internal::memcpy</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structllama_1_1Copy.html" title="Generic implementation of copy defaulting to fieldWiseCopy. LLAMA provides several specializations of...">Copy</a> the blobs' content from the source view to the destination view in parallel with the given thread configuration. Both views need to have the same mappings with the same array extents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadId</td><td>Zero-based id of calling thread for multi-threaded invocations. </td></tr>
    <tr><td class="paramname">threadCount</td><td>Thread count in case of multi-threaded invocation. </td></tr>
    <tr><td class="paramname">singleThreadMemcpy</td><td>The implementation of memcpy. By default: std::memcpy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Copy_8hpp_source.html#l00057">57</a> of file <a class="el" href="Copy_8hpp_source.html">Copy.hpp</a>.</p>

</div>
</div>
<a id="a33a2a1438ebfa33ecdae893ab0b93e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2a1438ebfa33ecdae893ab0b93e37">&#9670;&nbsp;</a></span>NrAndOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1NrAndOffset.html">llama::NrAndOffset</a> </td>
          <td>(</td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; Int &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa969f915a561005ba54a2c698a184965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa969f915a561005ba54a2c698a184965">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeTypeA , SizeTypeA... SizesA, typename SizeTypeB , SizeTypeB... SizesB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeA, SizesA... &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeB, SizesB... &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00215">215</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a91513e7294d6476ee4c4362a4093997f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91513e7294d6476ee4c4362a4093997f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename TA , typename TB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TA, Dim &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TB, Dim &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00037">37</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a4a8faed7400b66b8a3d13185ea2a26e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8faed7400b66b8a3d13185ea2a26e4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00178">178</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a07c4b4fb7b3d91e88bca98224400ac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c4b4fb7b3d91e88bca98224400ac32">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ElementsA, typename... ElementsB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsA... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsB... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00180">180</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="a20099242b7f987d98d361a5f46ab90ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20099242b7f987d98d361a5f46ab90ae">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... CoordsA, std::size_t... CoordsB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsA... &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsB... &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00054">54</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a6b9492ccf576f0f3683d893e35882a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9492ccf576f0f3683d893e35882a54">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp;
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00249">249</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="a4d7c3018578c28fe8a22d817570dbfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7c3018578c28fe8a22d817570dbfca">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, OwnView &gt; &amp;&#160;</td>
          <td class="paramname"><em>vr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp;
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00800">800</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a056e745a18ef7e0342d719e1ce678b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056e745a18ef7e0342d719e1ce678b17">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... RCs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; RCs... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::ostream&amp;
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00069">69</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a1cb8ee545443974c602115ab987f05e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb8ee545443974c602115ab987f05e7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeTypeA , SizeTypeA... SizesA, typename SizeTypeB , SizeTypeB... SizesB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeA, SizesA... &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeTypeB, SizesB... &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00206">206</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a491b771e37f3d0b8668883df9d0c02d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491b771e37f3d0b8668883df9d0c02d0">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dim, typename TA , typename TB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TA, Dim &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayIndex.html">ArrayIndex</a>&lt; TB, Dim &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00027">27</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a5c7f2c72590f73698ff6f31ba44ec0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7f2c72590f73698ff6f31ba44ec0a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1NrAndOffset.html">NrAndOffset</a>&lt; TB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00171">171</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ad527d6d304c87d6ab25d4d78e15cebc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad527d6d304c87d6ab25d4d78e15cebc4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ElementsA, typename... ElementsB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsA... &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; ElementsB... &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00168">168</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="a8aa8382ac8cefc8c2efceb8e4dab263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa8382ac8cefc8c2efceb8e4dab263a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Coords&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00047">47</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="abdf2ad9d154fb837e684d57779272efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf2ad9d154fb837e684d57779272efb">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... CoordsA, std::size_t... CoordsB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsA... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; CoordsB... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00040">40</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a73b682ef182dc8da7ec372afc84f1abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b682ef182dc8da7ec372afc84f1abc">&#9670;&nbsp;</a></span>popBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::popBack </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00291">291</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ac72b41ee8951d9b20dfbdc8630ea6e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b41ee8951d9b20dfbdc8630ea6e92">&#9670;&nbsp;</a></span>popFront() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::popFront </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00303">303</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="af3a49de4920182eda8ca9cf2bf57d0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a49de4920182eda8ca9cf2bf57d0f9">&#9670;&nbsp;</a></span>popFront() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Elements&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::popFront </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the tuple without the first element. </p>

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00268">268</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="a9e34d4e183a7bcc5759082b3844c19ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e34d4e183a7bcc5759082b3844c19ee">&#9670;&nbsp;</a></span>prettyRecordCoord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , std::size_t... Coords&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::prettyRecordCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code></td><td>)</td>
          <td> -&gt; std::string_view
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pretty representation of the record coordinate inside the given record dimension. Tags are interspersed by '.' and arrays are represented using subscript notation ("[123]"). </p>

<p class="definition">Definition at line <a class="el" href="StructName_8hpp_source.html#l00372">372</a> of file <a class="el" href="StructName_8hpp_source.html">StructName.hpp</a>.</p>

</div>
</div>
<a id="ae605c0e18c4839602eb4e7f2d6696c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae605c0e18c4839602eb4e7f2d6696c22">&#9670;&nbsp;</a></span>prettyRecordCoord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::prettyRecordCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::string_view
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructName_8hpp_source.html#l00380">380</a> of file <a class="el" href="StructName_8hpp_source.html">StructName.hpp</a>.</p>

</div>
</div>
<a id="af6efa2eebd35614750c0404652a0f7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6efa2eebd35614750c0404652a0f7d2">&#9670;&nbsp;</a></span>prettySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::prettySize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structllama_1_1PrettySize.html">PrettySize</a>
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repeatedly divides the given size (in bytes) until it fits below 1000. Returns the new size and a string literal with the corresponding unit. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00901">901</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="abab7973f7686f93f02ad33e4d0636a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7973f7686f93f02ad33e4d0636a25">&#9670;&nbsp;</a></span>product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; T
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00315">315</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="acb7f71db415ea884ba0c9d22a9bf5414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f71db415ea884ba0c9d22a9bf5414">&#9670;&nbsp;</a></span>product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SizeType , SizeType... Sizes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a>&lt; SizeType, Sizes... &gt;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; SizeType
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00224">224</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a582387ea1287dbab16833fc8da254d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582387ea1287dbab16833fc8da254d58">&#9670;&nbsp;</a></span>pushBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::pushBack </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structllama_1_1Array.html">Array</a>&lt;T, N + 1&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00279">279</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="afa7bf42db36a3e21c7819a833ed76ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7bf42db36a3e21c7819a833ed76ed2">&#9670;&nbsp;</a></span>pushFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::pushFront </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] <a class="el" href="structllama_1_1Array.html">Array</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="structllama_1_1Array.html">Array</a>&lt;T, N + 1&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Array_8hpp_source.html#l00267">267</a> of file <a class="el" href="Array_8hpp_source.html">Array.hpp</a>.</p>

</div>
</div>
<a id="ab9c5c0a1ca0698a8871689b9924736ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c5c0a1ca0698a8871689b9924736ac">&#9670;&nbsp;</a></span>roundUpToMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::roundUpToMultiple </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Integral
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the integral n rounded up to be a multiple of mult. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00578">578</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ad7dddd17106d2711c85b213e61fb9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dddd17106d2711c85b213e61fb9155">&#9670;&nbsp;</a></span>ScopedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1ScopedUpdate.html">llama::ScopedUpdate</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structllama_1_1ScopedUpdate.html">ScopedUpdate</a>&lt; typename <a class="el" href="structllama_1_1internal_1_1ReferenceTo.html">internal::ReferenceTo</a>&lt; std::remove_reference_t&lt; T &gt;&gt;::type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d2a40734074075e17bccd413a6f1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2a40734074075e17bccd413a6f1ec1">&#9670;&nbsp;</a></span>shallowCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View , typename NewBlobType  = CopyConst&lt;std::remove_reference_t&lt;View&gt;, std::byte&gt;*, typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;View&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::shallowCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a shallow copy of a view. This copy must not outlive the view, since it references its blob array. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NewBlobType</td><td>The blob type of the shallow copy. Must be a non owning pointer like type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new view with the same mapping as view, where each blob refers to the blob in view. </dd></dl>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00675">675</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="acebdbc18176bbf81e01c2b268665a94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebdbc18176bbf81e01c2b268665a94c">&#9670;&nbsp;</a></span>simdForEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; typename MakeSimd, template&lt; typename, auto &gt; typename MakeSizedSimd, typename View , typename UnarySimdFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::simdForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnarySimdFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00459">459</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a4451ec281eb037ebac7c08772ce0670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4451ec281eb037ebac7c08772ce0670f">&#9670;&nbsp;</a></span>simdForEachN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, template&lt; typename, auto &gt; typename MakeSizedSimd, typename View , typename UnarySimdFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void llama::simdForEachN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1View.html">View</a> &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnarySimdFunction&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00420">420</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="ad85a654e961eeb097cb3b557850e668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85a654e961eeb097cb3b557850e668b">&#9670;&nbsp;</a></span>storeSimd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Simd , typename TFwd &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void llama::storeSimd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSimd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>dstRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores SIMD vectors of element data from the given srcSimd into memory starting at the provided record reference. Only field tags occurring in <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a> are stored. If Simd contains multiple fields of SIMD types, a SIMD vector will be stored for each of the fields. The number of elements stored per SIMD vector depends on the SIMD width of the vector. Simd is allowed to have different vector lengths per element. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00363">363</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a8def4cdbf850f818833a38d67e6ebf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8def4cdbf850f818833a38d67e6ebf34">&#9670;&nbsp;</a></span>structName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::structName </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"> = <code>{}</code></td><td>)</td>
          <td> -&gt; std::string_view
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructName_8hpp_source.html#l00277">277</a> of file <a class="el" href="StructName_8hpp_source.html">StructName.hpp</a>.</p>

</div>
</div>
<a id="a08522ce66a9c0e6ac1b771e38a81d97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08522ce66a9c0e6ac1b771e38a81d97e">&#9670;&nbsp;</a></span>SubView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TStoredParentView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1SubView.html">llama::SubView</a> </td>
          <td>(</td>
          <td class="paramtype">TStoredParentView &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::remove_reference_t&lt; TStoredParentView &gt;::Mapping::ArrayExtents::Index&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structllama_1_1SubView.html">SubView</a>&lt; TStoredParentView &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structllama_1_1SubView.html">SubView</a> vview(view); will store a reference to view. <a class="el" href="structllama_1_1SubView.html">SubView</a> vview(std::move(view)); will store the view. </p>

</div>
</div>
<a id="aebf7c7c54c4190a57a2cc1ad5c280453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf7c7c54c4190a57a2cc1ad5c280453">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewA , typename BoundRecordDimA , bool OwnViewA, typename ViewB , typename BoundRecordDimB , bool OwnViewB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewA, BoundRecordDimA, OwnViewA &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; ViewB, BoundRecordDimB, OwnViewB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;std::is_same_v&lt;
            typename <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt;ViewA, BoundRecordDimA, OwnViewA&gt;::AccessibleRecordDim,
            typename <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt;ViewB, BoundRecordDimB, OwnViewB&gt;::AccessibleRecordDim&gt;&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00782">782</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a188282c298c3e709ff8727fafd31b24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188282c298c3e709ff8727fafd31b24b">&#9670;&nbsp;</a></span>transformBlobs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewFwd , typename TransformBlobFunc , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::transformBlobs </td>
          <td>(</td>
          <td class="paramtype">ViewFwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TransformBlobFunc &amp;&#160;</td>
          <td class="paramname"><em>transformBlob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the given transformation to the blobs of a view and creates a new view with the transformed blobs and the same mapping and accessor as the old view. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00652">652</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a1604e8162498ff814c1b1efacd212e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1604e8162498ff814c1b1efacd212e95">&#9670;&nbsp;</a></span>Tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Elements&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structllama_1_1Tuple.html">llama::Tuple</a> </td>
          <td>(</td>
          <td class="paramtype">Elements...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; std::remove_cv_t&lt; std::remove_reference_t&lt; Elements &gt;&gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42df604d705148baf4262104f6541560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42df604d705148baf4262104f6541560">&#9670;&nbsp;</a></span>tupleCat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple1 , typename Tuple2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::tupleCat </td>
          <td>(</td>
          <td class="paramtype">const Tuple1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00201">201</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="af97abfc449e394428735699c5259f4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97abfc449e394428735699c5259f4a2">&#9670;&nbsp;</a></span>tupleReplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Pos, typename Tuple , typename Replacement &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::tupleReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structllama_1_1Tuple.html">Tuple</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Replacement &amp;&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of a tuple with the element at position Pos replaced by replacement. </p>

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00234">234</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="aba450a02d1e534f8cea4073bf6fda830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba450a02d1e534f8cea4073bf6fda830">&#9670;&nbsp;</a></span>tupleTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Elements, typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::tupleTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structllama_1_1Tuple.html">Tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a functor to every element of a tuple, creating a new tuple with the result of the element transformations. The functor needs to implement a template <code>operator()</code> to which all tuple elements are passed. </p>

<p class="definition">Definition at line <a class="el" href="Tuple_8hpp_source.html#l00259">259</a> of file <a class="el" href="Tuple_8hpp_source.html">Tuple.hpp</a>.</p>

</div>
</div>
<a id="a66091f10efa162f8e81cd6081ff155bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66091f10efa162f8e81cd6081ff155bf">&#9670;&nbsp;</a></span>withAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewAccessor , typename ViewFwd , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::withAccessor </td>
          <td>(</td>
          <td class="paramtype">ViewFwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewAccessor&#160;</td>
          <td class="paramname"><em>newAccessor</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00694">694</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a8bfcf783207896246153d05625310971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfcf783207896246153d05625310971">&#9670;&nbsp;</a></span>withMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NewMapping , typename ViewFwd , typename  = std::enable_if_t&lt;isView&lt;std::decay_t&lt;ViewFwd&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto llama::withMapping </td>
          <td>(</td>
          <td class="paramtype">ViewFwd &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewMapping&#160;</td>
          <td class="paramname"><em>newMapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00707">707</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af54c80b077fb3d417466c83d0d005907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54c80b077fb3d417466c83d0d005907">&#9670;&nbsp;</a></span>alignOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::alignOf = alignof(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The alignment of a type T. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00559">559</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a945addc7fc78f444f37bb79d099cfd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945addc7fc78f444f37bb79d099cfd84">&#9670;&nbsp;</a></span>alignOf&lt; Record&lt; Fields... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#af54c80b077fb3d417466c83d0d005907">llama::alignOf</a>&lt; <a class="el" href="structllama_1_1Record.html">Record</a>&lt; Fields... &gt; &gt; = <a class="el" href="namespacellama.html#a6f2067ffe5979128e7efaf1fd4c35810">flatAlignOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;<a class="el" href="structllama_1_1Record.html">Record</a>&lt;Fields...&gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The alignment of a record dimension if its fields would be in a normal struct. Effectively returns the maximum alignment value in the type list. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00565">565</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a1f5816e83615dc84a55b3c2e6f2a0237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5816e83615dc84a55b3c2e6f2a0237">&#9670;&nbsp;</a></span>dyn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::dyn = <a class="el" href="structllama_1_1internal_1_1Dyn.html">internal::Dyn</a>{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used as a template argument to <a class="el" href="structllama_1_1ArrayExtents.html">ArrayExtents</a> to mark a dynamic extent. </p>

<p class="definition">Definition at line <a class="el" href="ArrayExtents_8hpp_source.html#l00127">127</a> of file <a class="el" href="ArrayExtents_8hpp_source.html">ArrayExtents.hpp</a>.</p>

</div>
</div>
<a id="a6f2067ffe5979128e7efaf1fd4c35810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2067ffe5979128e7efaf1fd4c35810">&#9670;&nbsp;</a></span>flatAlignOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::flatAlignOf = <a class="el" href="namespacellama_1_1internal.html#a2413ee7f2d6487f7e306148cf2b46ac4">internal::flatAlignOfImpl</a>&lt;TypeList&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The alignment of a type list if its elements would be in a normal struct. Effectively returns the maximum alignment value in the type list. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00554">554</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aa6c960189f5edc242be631e2e8757914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c960189f5edc242be631e2e8757914">&#9670;&nbsp;</a></span>flatFieldCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::flatFieldCount = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of fields in the recursively expanded record dimension. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00486">486</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a0cf4c61546502674c83b7e32611aca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf4c61546502674c83b7e32611aca4d">&#9670;&nbsp;</a></span>flatFieldCount&lt; Child[N]&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">llama::flatFieldCount</a>&lt; Child[N]&gt; = <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;Child&gt; * N</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00495">495</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a9692409342a1118048ffccba3ed1938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692409342a1118048ffccba3ed1938e">&#9670;&nbsp;</a></span>flatFieldCount&lt; Record&lt; Children... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Children&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">llama::flatFieldCount</a>&lt; <a class="el" href="structllama_1_1Record.html">Record</a>&lt; Children... &gt; &gt; = (<a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;<a class="el" href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">GetFieldType</a>&lt;Children&gt;&gt; + ... + 0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00490">490</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a7b86f2441b1aae82532668e1a8377df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b86f2441b1aae82532668e1a8377df2">&#9670;&nbsp;</a></span>flatOffsetOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeList , std::size_t I, bool Align&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::flatOffsetOf = <a class="el" href="namespacellama_1_1internal.html#a8420725970ab9da75999e4dfad4e8590">internal::offsetOfImplWorkaround</a>&lt;TypeList, I, Align&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The byte offset of an element in a type list ifs elements would be in a normal struct. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00634">634</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a6c3056b43b48f32a66160a6dd273662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3056b43b48f32a66160a6dd273662d">&#9670;&nbsp;</a></span>flatRecordCoord</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename RecordCoord &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::flatRecordCoord = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The equivalent zero based index into a flat record dimension (<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>) of the given hierarchical record coordinate. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00517">517</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aef46edda82bf9ef35a2d461b77b5911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef46edda82bf9ef35a2d461b77b5911f">&#9670;&nbsp;</a></span>flatRecordCoord&lt; Child[N], RecordCoord&lt; I, Is... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child , std::size_t N, std::size_t I, std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">llama::flatRecordCoord</a>&lt; Child[N], <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; I, Is... &gt; &gt; = <a class="el" href="namespacellama.html#aa6c960189f5edc242be631e2e8757914">flatFieldCount</a>&lt;Child&gt; * I + <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a>&lt;Child, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;Is...&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00531">531</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a49085229ed957d67678ce1e04c704e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49085229ed957d67678ce1e04c704e67">&#9670;&nbsp;</a></span>flatRecordCoord&lt; Record&lt; Children... &gt;, RecordCoord&lt; I, Is... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Children, std::size_t I, std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">llama::flatRecordCoord</a>&lt; <a class="el" href="structllama_1_1Record.html">Record</a>&lt; Children... &gt;, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; I, Is... &gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespacellama_1_1internal.html#a1dc0436b8f0598e4fe3e707051be5b5f">internal::flatFieldCountBefore</a>&lt;I, Record&lt;Children...&gt;&gt;</div>
<div class="line">        + <a class="code" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a>&lt;<a class="code" href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">GetFieldType</a>&lt;mp_at_c&lt;Record&lt;Children...&gt;, I&gt;&gt;, RecordCoord&lt;Is...&gt;&gt;</div>
<div class="ttc" id="anamespacellama_1_1internal_html_a1dc0436b8f0598e4fe3e707051be5b5f"><div class="ttname"><a href="namespacellama_1_1internal.html#a1dc0436b8f0598e4fe3e707051be5b5f">llama::internal::flatFieldCountBefore</a></div><div class="ttdeci">constexpr std::size_t flatFieldCountBefore</div><div class="ttdef"><b>Definition:</b> <a href="Core_8hpp_source.html#l00500">Core.hpp:500</a></div></div>
<div class="ttc" id="anamespacellama_html_a6c3056b43b48f32a66160a6dd273662d"><div class="ttname"><a href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">llama::flatRecordCoord</a></div><div class="ttdeci">constexpr std::size_t flatRecordCoord</div><div class="ttdef"><b>Definition:</b> <a href="Core_8hpp_source.html#l00517">Core.hpp:517</a></div></div>
<div class="ttc" id="anamespacellama_html_a75dfd56127d13358c2991a57340657dc"><div class="ttname"><a href="namespacellama.html#a75dfd56127d13358c2991a57340657dc">llama::GetFieldType</a></div><div class="ttdeci">mp_second&lt; Field &gt; GetFieldType</div><div class="ttdoc">Get the type from a Field.</div><div class="ttdef"><b>Definition:</b> <a href="Core_8hpp_source.html#l00191">Core.hpp:191</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00525">525</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a03ce8695c9b67882c44356056ad3156d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ce8695c9b67882c44356056ad3156d">&#9670;&nbsp;</a></span>flatRecordCoord&lt; T, RecordCoord&lt;&gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">llama::flatRecordCoord</a>&lt; T, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt;&gt; &gt; = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00521">521</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ac8f48517b46c35c1a511273f08d2abb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f48517b46c35c1a511273f08d2abb3">&#9670;&nbsp;</a></span>flatSizeOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeList , bool Align, bool IncludeTailPadding = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::flatSizeOf = <a class="el" href="namespacellama_1_1internal.html#aeab53e4609fe07abfb6f5f2d532cd388">internal::sizeOfImpl</a>&lt;TypeList, Align, IncludeTailPadding&gt;()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of a type list if its elements would be in a normal struct. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00618">618</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a156385d5598b772070206225a5093266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156385d5598b772070206225a5093266">&#9670;&nbsp;</a></span>hasAnyComputedField</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::hasAnyComputedField</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= mp_any_of&lt;</div>
<div class="line">        LeafRecordCoords&lt;typename Mapping::RecordDim&gt;,</div>
<div class="line">        mp_bind_front&lt;internal::IsComputed, Mapping&gt;::template fn&gt;::value</div>
</div><!-- fragment -->
<p>Returns true if any field accessed via the given mapping is a computed value. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00090">90</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a39d280955e5b9deb36f6c8fa1124ca2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d280955e5b9deb36f6c8fa1124ca2b">&#9670;&nbsp;</a></span>hasSameTags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDimA , typename RecordCoordA , typename RecordDimB , typename RecordCoordB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::hasSameTags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []() constexpr</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> constexpr(RecordCoordA::size != RecordCoordB::size)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> constexpr(RecordCoordA::size == 0 &amp;&amp; RecordCoordB::size == 0)</div>
<div class="line">            return true;</div>
<div class="line">        else</div>
<div class="line">            return std::is_same_v&lt;<a class="code" href="namespacellama.html#a4a4fd33218cce7b2e592486d80f2ae90">GetTags</a>&lt;RecordDimA, RecordCoordA&gt;, <a class="code" href="namespacellama.html#a4a4fd33218cce7b2e592486d80f2ae90">GetTags</a>&lt;RecordDimB, RecordCoordB&gt;&gt;;</div>
<div class="line">    }()</div>
<div class="ttc" id="anamespacellama_html_a4a4fd33218cce7b2e592486d80f2ae90"><div class="ttname"><a href="namespacellama.html#a4a4fd33218cce7b2e592486d80f2ae90">llama::GetTags</a></div><div class="ttdeci">typename internal::GetTagsImpl&lt; RecordDim, RecordCoord &gt;::type GetTags</div><div class="ttdef"><b>Definition:</b> <a href="Core_8hpp_source.html#l00233">Core.hpp:233</a></div></div>
</div><!-- fragment --><p>Is true if, starting at two coordinates in two record dimensions, all subsequent nodes in the record dimension tree have the same tag. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecordDimA</td><td>First record dimension. </td></tr>
    <tr><td class="paramname">RecordCoordA</td><td><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> based on RecordDimA along which the tags are compared. </td></tr>
    <tr><td class="paramname">RecordDimB</td><td>second record dimension. </td></tr>
    <tr><td class="paramname">RecordCoordB</td><td><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> based on RecordDimB along which the tags are compared. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00263">263</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="acca32b49e2be7c3c136e940939c531ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca32b49e2be7c3c136e940939c531ae">&#9670;&nbsp;</a></span>isAllowedFieldType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isAllowedFieldType = std::is_trivially_destructible_v&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells whether the given type is allowed as a field type in LLAMA. Such types need to be trivially constructible and trivially destructible. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00028">28</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a9676a3903b134df116791bcae533d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9676a3903b134df116791bcae533d6c6">&#9670;&nbsp;</a></span>isComputed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename RecordCoord &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isComputed = <a class="el" href="structllama_1_1internal_1_1IsComputed.html">internal::IsComputed</a>&lt;Mapping, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the field accessed via the given mapping and record coordinate is a computed value. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00084">84</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="aeb3261387e3af25b2f65fb3725bacde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3261387e3af25b2f65fb3725bacde1">&#9670;&nbsp;</a></span>isConstant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isConstant = <a class="el" href="structllama_1_1internal_1_1IsConstant.html">internal::IsConstant</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00846">846</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a75482a9b4713c755f75805bd247866e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75482a9b4713c755f75805bd247866e9">&#9670;&nbsp;</a></span>isField</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isField = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00046">46</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="ae026262aaccd3c32d553a96d7a56e8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026262aaccd3c32d553a96d7a56e8b3">&#9670;&nbsp;</a></span>isField&lt; Field&lt; Tag, Type &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacellama.html#a75482a9b4713c755f75805bd247866e9">llama::isField</a>&lt; <a class="el" href="structllama_1_1Field.html">Field</a>&lt; Tag, Type &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00050">50</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="aecf6a2d8f8fd3cde95667fbf433e42d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf6a2d8f8fd3cde95667fbf433e42d1">&#9670;&nbsp;</a></span>isOne</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isOne = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is true, if T is an instance of <a class="el" href="namespacellama.html#a7b33b2c30fa081e8352cf12c7b98b0eb">One</a>. </p>

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00198">198</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a44aec444f97e67c053400d58fae4126b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aec444f97e67c053400d58fae4126b">&#9670;&nbsp;</a></span>isOne&lt; RecordRef&lt; View, BoundRecordCoord, true &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View , typename BoundRecordCoord &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacellama.html#aecf6a2d8f8fd3cde95667fbf433e42d1">llama::isOne</a>&lt; <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, true &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00202">202</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="a06e1dd12e96257f3aaf7a1ea6b9eead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e1dd12e96257f3aaf7a1ea6b9eead8">&#9670;&nbsp;</a></span>isProxyReference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isProxyReference = <a class="el" href="structllama_1_1internal_1_1IsProxyReferenceImpl.html">internal::IsProxyReferenceImpl</a>&lt;R&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Concepts_8hpp_source.html#l00235">235</a> of file <a class="el" href="Concepts_8hpp_source.html">Concepts.hpp</a>.</p>

</div>
</div>
<a id="a3b2aa8fd3e43e43b830bc4a71b180175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2aa8fd3e43e43b830bc4a71b180175">&#9670;&nbsp;</a></span>isRecord</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::isRecord = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00195">195</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="adee8dc812f8d14dbea092728c88a937d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee8dc812f8d14dbea092728c88a937d">&#9670;&nbsp;</a></span>isRecord&lt; Record&lt; Fields... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespacellama.html#a3b2aa8fd3e43e43b830bc4a71b180175">llama::isRecord</a>&lt; <a class="el" href="structllama_1_1Record.html">Record</a>&lt; Fields... &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00199">199</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a548294a2b7b4f2e76954d9cf9edcdec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548294a2b7b4f2e76954d9cf9edcdec7">&#9670;&nbsp;</a></span>isRecordCoord</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isRecordCoord = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00061">61</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a9c898b6940a90559b91b4057b85fb74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c898b6940a90559b91b4057b85fb74b">&#9670;&nbsp;</a></span>isRecordCoord&lt; RecordCoord&lt; Coords... &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Coords&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="namespacellama.html#a548294a2b7b4f2e76954d9cf9edcdec7">llama::isRecordCoord</a>&lt; <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&lt; Coords... &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00065">65</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="ab8f37f9e6c5055a9fa84709a6c5e5304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f37f9e6c5055a9fa84709a6c5e5304">&#9670;&nbsp;</a></span>isRecordDim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool llama::isRecordDim = <a class="el" href="namespacellama.html#a3b2aa8fd3e43e43b830bc4a71b180175">isRecord</a>&lt;T&gt; || <a class="el" href="structllama_1_1internal_1_1IsBoundedArray.html">internal::IsBoundedArray</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the T is a record dimension. That is, T is either a <a class="el" href="structllama_1_1Record.html" title="A type list of Fields which may be used to define a record dimension.">llama::Record</a> or a bounded array. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00698">698</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="af3acf31ae1481251861f38e12ee58dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3acf31ae1481251861f38e12ee58dda">&#9670;&nbsp;</a></span>isRecordRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::isRecordRef = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00024">24</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a88abd408b8ac8bd2456a8316a62a5928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88abd408b8ac8bd2456a8316a62a5928">&#9670;&nbsp;</a></span>isRecordRef&lt; RecordRef&lt; View, BoundRecordCoord, OwnView &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View , typename BoundRecordCoord , bool OwnView&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespacellama.html#af3acf31ae1481251861f38e12ee58dda">llama::isRecordRef</a>&lt; <a class="el" href="structllama_1_1RecordRef.html">RecordRef</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>, BoundRecordCoord, OwnView &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RecordRef_8hpp_source.html#l00028">28</a> of file <a class="el" href="RecordRef_8hpp_source.html">RecordRef.hpp</a>.</p>

</div>
</div>
<a id="a2c3ef24f7ab0d71912a5f7e71cf24130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3ef24f7ab0d71912a5f7e71cf24130">&#9670;&nbsp;</a></span>isView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename View &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::isView = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00605">605</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="abada4e4a295e9cacca30c9bebd6f5dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abada4e4a295e9cacca30c9bebd6f5dbf">&#9670;&nbsp;</a></span>isView&lt; View&lt; Mapping, BlobType, Accessor &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mapping , typename BlobType , typename Accessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="namespacellama.html#a2c3ef24f7ab0d71912a5f7e71cf24130">llama::isView</a>&lt; <a class="el" href="structllama_1_1View.html">View</a>&lt; Mapping, BlobType, Accessor &gt; &gt; = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="View_8hpp_source.html#l00610">610</a> of file <a class="el" href="View_8hpp_source.html">View.hpp</a>.</p>

</div>
</div>
<a id="aae03df933faef61723569d4655563bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae03df933faef61723569d4655563bbe">&#9670;&nbsp;</a></span>offsetOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , typename RecordCoord , bool Align = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::offsetOf = <a class="el" href="namespacellama.html#a7b86f2441b1aae82532668e1a8377df2">flatOffsetOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;RecordDim&gt;, <a class="el" href="namespacellama.html#a6c3056b43b48f32a66160a6dd273662d">flatRecordCoord</a>&lt;RecordDim, <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>&gt;, Align&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The byte offset of an element in a record dimension if it would be a normal struct. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecordDim</td><td><a class="el" href="structllama_1_1Record.html" title="A type list of Fields which may be used to define a record dimension.">Record</a> dimension tree. </td></tr>
    <tr><td class="paramname"><a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a></td><td><a class="el" href="structllama_1_1Record.html" title="A type list of Fields which may be used to define a record dimension.">Record</a> coordinate of an element inrecord dimension tree. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00661">661</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a06d7068ee2176f6a3bbd750665ac5af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d7068ee2176f6a3bbd750665ac5af0">&#9670;&nbsp;</a></span>qualifiedTypeName</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::qualifiedTypeName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []</div>
<div class="line">    {</div>
<div class="line">        constexpr <span class="keyword">auto</span>&amp; value = internal::typeNameStorage&lt;T&gt;;</div>
<div class="line">        <span class="keywordflow">return</span> std::string_view{value.data(), value.size()};</div>
<div class="line">    }()</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="StructName_8hpp_source.html#l00198">198</a> of file <a class="el" href="StructName_8hpp_source.html">StructName.hpp</a>.</p>

</div>
</div>
<a id="a8660330eb77e8654033787e86b8da6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8660330eb77e8654033787e86b8da6ed">&#9670;&nbsp;</a></span>recordCoordCommonPrefixIsBigger</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::recordCoordCommonPrefixIsBigger = <a class="el" href="namespacellama_1_1internal.html#a02e115f3c9d3acdccd07526d475ed358">internal::recordCoordCommonPrefixIsBiggerImpl</a>(First{}, Second{})</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks wether the first <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a> is bigger than the second. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00153">153</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a50289a09b368b8f1c333e3d6feb49398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50289a09b368b8f1c333e3d6feb49398">&#9670;&nbsp;</a></span>recordCoordCommonPrefixIsSame</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::recordCoordCommonPrefixIsSame = <a class="el" href="namespacellama_1_1internal.html#a5732c14ad8045af3e542cf23a7e82c6d">internal::recordCoordCommonPrefixIsSameImpl</a>(First{}, Second{})</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two <a class="el" href="structllama_1_1RecordCoord.html">RecordCoord</a>s are the same or one is the prefix of the other. </p>

<p class="definition">Definition at line <a class="el" href="RecordCoord_8hpp_source.html#l00174">174</a> of file <a class="el" href="RecordCoord_8hpp_source.html">RecordCoord.hpp</a>.</p>

</div>
</div>
<a id="a85e41b88e239189c88b2d895bfc2691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e41b88e239189c88b2d895bfc2691e">&#9670;&nbsp;</a></span>simdLanes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Simd , typename SFINAE  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto llama::simdLanes = <a class="el" href="structllama_1_1SimdTraits.html">SimdTraits</a>&lt;<a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a>&gt;::lanes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of SIMD simdLanes the given SIMD vector or <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd&lt;T&gt;</a> has. If Simd is not a structural <a class="el" href="namespacellama.html#adf42387a56b588d4a261b9ab869e33ee">Simd</a> or <a class="el" href="namespacellama.html#a2f1e01829ca6b6d3a50720fdbcc99adf">SimdN</a>, this is a shortcut for SimdTraits&lt;Simd&gt;::lanes. </p>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00070">70</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a34f90853e28950fdd34ecf9696ae1f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f90853e28950fdd34ecf9696ae1f63">&#9670;&nbsp;</a></span>simdLanesWithFullVectorsFor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::simdLanesWithFullVectorsFor = <a class="el" href="namespacellama.html#abb21e8bcb7c41613b7183a1beef1f600">chooseSimdLanes</a>&lt;RecordDim, MakeSimd&gt;([](auto a, auto b) { return std::max(a, b); })</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the number of simd lanes suitable to process all types occurring in the given record dimension. The algorithm ensures that even SIMD vectors for the smallest field type are filled completely and may thus require multiple SIMD vectors for some field types. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecordDim</td><td>The record dimension to simdize </td></tr>
    <tr><td class="paramname">MakeSimd</td><td>Type function creating a SIMD type given a field type from the record dimension. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00099">99</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="ac902aa26f43ee2c8cceeb580a1df0c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac902aa26f43ee2c8cceeb580a1df0c50">&#9670;&nbsp;</a></span>simdLanesWithLeastRegistersFor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RecordDim , template&lt; typename &gt; typename MakeSimd&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::simdLanesWithLeastRegistersFor = <a class="el" href="namespacellama.html#abb21e8bcb7c41613b7183a1beef1f600">chooseSimdLanes</a>&lt;RecordDim, MakeSimd&gt;([](auto a, auto b) { return std::min(a, b); })</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the number of simd lanes suitable to process all types occurring in the given record dimension. The algorithm ensures that the smallest number of SIMD registers is needed and may thus only partially fill registers for some data types. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RecordDim</td><td>The record dimension to simdize </td></tr>
    <tr><td class="paramname">MakeSimd</td><td>Type function creating a SIMD type given a field type from the record dimension. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Simd_8hpp_source.html#l00109">109</a> of file <a class="el" href="Simd_8hpp_source.html">Simd.hpp</a>.</p>

</div>
</div>
<a id="a2404e09083dc2c685bc283cd4ead0edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2404e09083dc2c685bc283cd4ead0edc">&#9670;&nbsp;</a></span>sizeOf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool Align = false, bool IncludeTailPadding = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t llama::sizeOf = sizeof(T)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of a type T. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00623">623</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
<a id="a585d55cd3a51152ec452bc1f2d49a3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585d55cd3a51152ec452bc1f2d49a3ec">&#9670;&nbsp;</a></span>sizeOf&lt; Record&lt; Fields... &gt;, Align, IncludeTailPadding &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Fields, bool Align, bool IncludeTailPadding&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="namespacellama.html#a2404e09083dc2c685bc283cd4ead0edc">llama::sizeOf</a>&lt; <a class="el" href="structllama_1_1Record.html">Record</a>&lt; Fields... &gt;, Align, IncludeTailPadding &gt; = <a class="el" href="namespacellama.html#ac8f48517b46c35c1a511273f08d2abb3">flatSizeOf</a>&lt;<a class="el" href="namespacellama.html#a1fddf1f638927edfb8da8e3c78da4e1c">FlatRecordDim</a>&lt;<a class="el" href="structllama_1_1Record.html">Record</a>&lt;Fields...&gt;&gt;, Align, IncludeTailPadding&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of a record dimension if its fields would be in a normal struct. </p>

<p class="definition">Definition at line <a class="el" href="Core_8hpp_source.html#l00628">628</a> of file <a class="el" href="Core_8hpp_source.html">Core.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacellama.html">llama</a></li>
    <li class="footer">Generated on Sun Jan 7 2024 17:37:15 for Low-Level Abstraction of Memory Access by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
